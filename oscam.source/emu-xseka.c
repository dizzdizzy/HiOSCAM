#include "globals.h"
#if defined(MODULE_XCAS)
#include "oscam-client.h"
#include "oscam-ecm.h"
#include "oscam-net.h"
#include "oscam-chk.h"
#include "oscam-string.h"
#include "cscrypt/bn.h"
#include "cscrypt/sha1.h"
#include "cscrypt/des.h"
#include "module-xcas.h"
#if defined(__XCAS_SEKA__)
//
//
//	5101, 5102, 5105, 5109	<-- HACK
//	5103, 5104, 5106, 5107, 5108, 510A
enum
{
	#ifdef _DPLUS_SUPPORT_
		SEKAII_PR_64,
		SEKAII_PR_67,
	#endif
	#ifdef _CYFRA_SUPPORT_
		SEKAII_PR_65,
	#endif
	#ifdef _CANAL_NL_SUPPORT_
		SEKAII_PR_6A,
	#endif
	#ifdef _SKYITALIA_SUPPORT_
		SEKAII_PR_70,
		SEKAII_PR_71,
		SEKAII_PR_72,
	#endif
	SEKAII_PR_NULL,
	MAX_SEKAII_PRS
};
enum
{
	#ifdef _DPLUS_SUPPORT_
		SEKAII_ISSUER_DPLUS,
	#endif
	#ifdef _CYFRA_SUPPORT_
		SEKAII_ISSUER_CYFRA,
	#endif
	#ifdef _CANAL_NL_SUPPORT_
		SEKAII_ISSUER_CANALPLUS,
	#endif
	#ifdef _SKYITALIA_SUPPORT_
		SEKAII_ISSUER_SKYITALIA,
	#endif
	SEKAII_ISSUER_NULL,
	MAX_SEKAII_ISSUERS
};



typedef struct
{
	uint8_t tid;
	uint8_t sctlen1;
	uint8_t sctlen2;
	uint8_t id[2];
	uint8_t unknown;
	uint8_t sm;
	uint8_t keynr;
} SEKA_ECM;
typedef	SEKA_ECM	SEKA_SECTION;
/*
84 0063
00 70 -- 3..4 ident
0A 2C B9 -- 5..7 shared address
00 --  8 keyselect
B1 --  9 P2
10 -- 10 P3
03 -- 11 P4
1808AC2E1C5F488F8951575DB58C99E659D10175EF3859AA73C93A385246D8E4455C25BEE42C006CF
88CE4507157D323ACCA0FA445BE4C2134B53DF55BB8AE07AEE75644F0C4D735A83319BE0C8DCD66DB
0C431D235B4F884D18
*/
typedef struct
{
	uint8_t tid;
	uint8_t sctlen1;
	uint8_t sctlen2;
	uint8_t id[2];
	uint8_t sa[3];
	uint8_t sm;
	uint8_t keynr;
} SEKA_EMM_S;
/*
82 006B
00 00 -- 3..4 always 0000
09 90 3F 65 -- 5..8 UA
00 64 -- 9..A Provi id
00	  -- 0xB keyselect
B0	  -- 0xC P2
10	  -- 0xD P3
01	  -- 0xE P4
--- 0xF - encrypted data ---
5F1444083352D555F14D3B302481FBFDB446CA17C27B4DE12F5E116FB2A25AA8947AC5D963AF
F90BA59E14CD558EDEDF585E476A486BF362D7D63EBE6A43013CB43F6E6B44065904F9E57B38
3C047FD0CE8C60FBCC703D0D26B83803739855
*/
typedef struct
{
	uint8_t tid;
	uint8_t sctlen1;
	uint8_t sctlen2;
	uint8_t ua[6];
	uint8_t id[2];
	uint8_t sm;
	uint8_t keynr;
} SEKA_EMM_U;

#define _seka_tid_(x) 	(((SEKA_SECTION *)(x))->tid)
#define _seka_sa_(x)  	(((SEKA_EMM_S *)(x))->sa)
#define _seka_sid_(x) 	(((SEKA_EMM_S *)(x))->id)
#define _seka_ua_(x)  	(((SEKA_EMM_U *)(x))->ua)
#define _seka_uid_(x) 	(((SEKA_EMM_U *)(x))->id)

#define _seka_sn8_(b) 		(((b&0xf0)>>4)+((b&0xf)<<4))
#define _seka_w16_(buffer,idx,mask) (((buffer[(idx)]<<8) + buffer[(idx)+1]) & mask)
#define _seka_rl16_(s,t) 	(((s)<<(t)) | (((s)&0xFFFF)>>(16-(t))))
#define _seka_rr16_(s,t) 	((((s)&0xFFFF)>>(t)) | ((s)<<(16-(t))))

#define	MAX_SEKA_PROV		4
typedef struct
{
	uint8_t 	ident	 [MAX_SEKA_PROV];
	uint8_t 	ecmMods[3][90];	// 0x10E
	uint8_t 	ecmExps[3][6]; 	// 0x12
	uint8_t 	emmMods[3][90];	// 0x10E
	uint8_t 	emmExps[3][6]; 	// 0x12
} SEKAII_PROVI;

typedef struct
{
	uint16_t ident	[MAX_SEKA_PROV];
	uint8_t 	shapad;
	uint8_t 	shaend;

	uint8_t 	*t19x;
	uint8_t 	*t1Bx;
	uint8_t 	*t1Fx;

	uint8_t 	*t29x;
	uint8_t 	*t2Bx;
	uint8_t 	*t2Fx;

	uint8_t 	*masktab;

	uint8_t	*xt;
	uint8_t	*pt;
} SEKAII_ISSUER;

//
//
//
	#define	_SEKA2NEW70_MASKTABLE_
//
//
//
//----------------------------------------------------------------------
//----------------------------------------------------------------------
//----------------------------------------------------------------------
static uint8_t 	seka_TD[4] 	 = { 1, 3, 0, 2 };
static uint8_t 	seka_T1[256] =
{
	0x2a,0xe1,0x0b,0x13,0x3e,0x6e,0x32,0x48,
	0xd3,0x31,0x08,0x8c,0x8f,0x95,0xbd,0xd0,
	0xe4,0x6d,0x50,0x81,0x20,0x30,0xbb,0x75,
	0xf5,0xd4,0x7c,0x87,0x2c,0x4e,0xe8,0xf4,
	0xbe,0x24,0x9e,0x4d,0x80,0x37,0xd2,0x5f,
	0xdb,0x04,0x7a,0x3f,0x14,0x72,0x67,0x2d,
	0xcd,0x15,0xa6,0x4c,0x2e,0x3b,0x0c,0x41,
	0x62,0xfa,0xee,0x83,0x1e,0xa2,0x01,0x0e,//8
	0x7f,0x59,0xc9,0xb9,0xc4,0x9d,0x9b,0x1b,
	0x9c,0xca,0xaf,0x3c,0x73,0x1a,0x65,0xb1,
	0x76,0x84,0x39,0x98,0xe9,0x53,0x94,0xba,
	0x1d,0x29,0xcf,0xb4,0x0d,0x05,0x7d,0xd1,
	0xd7,0x0a,0xa0,0x5c,0x91,0x71,0x92,0x88,
	0xab,0x93,0x11,0x8a,0xd6,0x5a,0x77,0xb5,
	0xc3,0x19,0xc1,0xc7,0x8e,0xf9,0xec,0x35,
	0x4b,0xcc,0xd9,0x4a,0x18,0x23,0x9f,0x52,//16
	0xdd,0xe3,0xad,0x7b,0x47,0x97,0x60,0x10,
	0x43,0xef,0x07,0xa5,0x49,0xc6,0xb3,0x55,
	0x28,0x51,0x5d,0x64,0x66,0xfc,0x44,0x42,
	0xbc,0x26,0x09,0x74,0x6f,0xf7,0x6b,0x4f,
	0x2f,0xf0,0xea,0xb8,0xae,0xf3,0x63,0x6a,
	0x56,0xb2,0x02,0xd8,0x34,0xa4,0x00,0xe6,
	0x58,0xeb,0xa3,0x82,0x85,0x45,0xe0,0x89,
	0x7e,0xfd,0xf2,0x3a,0x36,0x57,0xff,0x06,//24
	0x69,0x54,0x79,0x9a,0xb6,0x6c,0xdc,0x8b,
	0xa7,0x1f,0x90,0x03,0x17,0x1c,0xed,0xd5,
	0xaa,0x5e,0xfe,0xda,0x78,0xb0,0xbf,0x12,
	0xa8,0x22,0x21,0x3d,0xc2,0xc0,0xb7,0xa9,
	0xe7,0x33,0xfb,0xf1,0x70,0xe5,0x17,0x96,
	0xf8,0x8d,0x46,0xa1,0x86,0xe2,0x40,0x38,
	0xf6,0x68,0x25,0x16,0xac,0x61,0x27,0xcb,
	0x5b,0xc8,0x2b,0x0f,0x99,0xde,0xce,0xc5
};//32 * 8 = 256

static uint8_t 	seka_T2[256] =
{
	0xbf,0x11,0x6d,0xfa,0x26,0x7f,0xf3,0xc8,
	0x9e,0xdd,0x3f,0x16,0x97,0xbd,0x08,0x80,
	0x51,0x42,0x93,0x49,0x5b,0x64,0x9b,0x25,
	0xf5,0x0f,0x24,0x34,0x44,0xb8,0xee,0x2e,
	0xda,0x8f,0x31,0xcc,0xc0,0x5e,0x8a,0x61,
	0xa1,0x63,0xc7,0xb2,0x58,0x09,0x4d,0x46,
	0x81,0x82,0x68,0x4b,0xf6,0xbc,0x9d,0x03,
	0xac,0x91,0xe8,0x3d,0x94,0x37,0xa0,0xbb, //8
	0xce,0xeb,0x98,0xd8,0x38,0x56,0xe9,0x6b,
	0x28,0xfd,0x84,0xc6,0xcd,0x5f,0x6e,0xb6,
	0x32,0xf7,0x0e,0xf1,0xf8,0x54,0xc1,0x53,
	0xf0,0xa7,0x95,0x7b,0x19,0x21,0x23,0x7d,
	0xe1,0xa9,0x75,0x3e,0xd6,0xed,0x8e,0x6f,
	0xdb,0xb7,0x07,0x41,0x05,0x77,0xb4,0x2d,
	0x45,0xdf,0x29,0x22,0x43,0x89,0x83,0xfc,
	0xd5,0xa4,0x88,0xd1,0xf4,0x55,0x4f,0x78,//16
	0x62,0x1e,0x1d,0xb9,0xe0,0x2f,0x01,0x13,
	0x15,0xe6,0x17,0x6a,0x8d,0x0c,0x96,0x7e,
	0x86,0x27,0xa6,0x0d,0xb5,0x73,0x71,0xaa,
	0x36,0xd0,0x06,0x66,0xdc,0xb1,0x2a,0x5a,
	0x72,0xbe,0x3a,0xc5,0x40,0x65,0x1b,0x02,
	0x10,0x9f,0x3b,0xf9,0x2b,0x18,0x5c,0xd7,
	0x12,0x47,0xef,0x1a,0x87,0xd2,0xc2,0x8b,
	0x99,0x9c,0xd3,0x57,0xe4,0x76,0x67,0xca,//24
	0x3c,0xfb,0x90,0x20,0x14,0x48,0xc9,0x60,
	0xb0,0x70,0x4e,0xa2,0xad,0x35,0xea,0xc4,
	0x74,0xcb,0x39,0xde,0xe7,0xd4,0xa3,0xa5,
	0x04,0x92,0x8c,0xd9,0x7c,0x1c,0x7a,0xa8,
	0x52,0x79,0xf2,0x33,0xba,0x1f,0x30,0x9a,
	0x00,0x50,0x4c,0xff,0xe5,0xcf,0x59,0xc3,
	0xe3,0x0a,0x85,0xb3,0xae,0xec,0x0b,0xfe,
	0xe2,0xab,0x4a,0xaf,0x69,0x6c,0x2c,0x5d
};	// 32 * 8 = 256

#ifdef _DPLUS_SUPPORT_
	#include "./emu_seka2_xxhash.h"
	#include "./emu_seka2_64hash.h"
	#include "./emu_seka2_64mt.h"
#endif

#ifdef _CANAL_NL_SUPPORT_
	#include "./emu_seka2_6a.h"
	#include "./emu_seka2_6ahash.h"
	#include "./emu_seka2_6amt.h"
	#include "./emu_seka2_sse.h"
#endif

#ifdef _CYFRA_SUPPORT_
	#include "./emu_seka2_65hash.h"
	#include "./emu_seka2_65mt.h"
#endif

#ifdef _CANAL_FR_SUPPORT_
	#include "./emu_seka2_80.h"
	#include "./emu_seka2_80hash.h"
	#include "./emu_seka2_80mt.h"
	#include "./emu_seka2_81hash.h"
	#include "./emu_seka2_81mt.h"
	#include "./emu_seka2_sse.h"
#endif

#ifdef _SKYITALIA_SUPPORT_
	#include "./emu_seka2_70hash.h"
	#include "./emu_seka2_70mt.h"
#endif

//
// uint8_t *T1, *T2;
/* 8 seca2 Providers allowed*/
static uint8_t 	seka2_provi_data[] =
{
	#ifdef _DPLUS_SUPPORT_
		// -----------------------------
		// ------------- 00 64 ---------
		0x64,0,0,0,
		/*ECM_MOD0*/	0x35,0x9A,0x3E,0xD5,0xF5,0x1B,0x03,0xB6,0x61,0x16,0xA8,0x32,0xFC,0x32,0xB0,0xC5,
						0x2F,0xFA,0x1A,0x51,0xB4,0x5F,0xBF,0x0E,0x00,0x7A,0xBD,0x74,0x0E,0x9F,0x14,0x87,
						0xAC,0xF1,0xA6,0x22,0xF0,0xF0,0x03,0x70,0x64,0x29,0xD4,0x72,0x4C,0x41,0x9E,0xBE,
						0x3F,0x31,0x95,0xE0,0x2D,0x83,0xCF,0x44,0xF3,0x27,0xCA,0xCF,0x2A,0x76,0x77,0x00,
						0x60,0x11,0x70,0x01,0xC9,0x66,0x05,0xFC,0x4C,0xA9,0xD3,0xD7,0x1F,0x45,0x96,0x3A,
						0x7E,0xD3,0x90,0x76,0xF2,0x3A,0xCC,0xCD,0x14,0x9F,
		/*ECM_MOD1*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		/*ECM_MOD2*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		/*ECM_EXP0*/	0x25,0x43,0xE6,0x44,0xE3,0xA0,
		/*ECM_EXP1*/	0,0,0,0,0,0,
		/*ECM_EXP2*/	0,0,0,0,0,0,
		/*EMM_MOD0*/	0x21,0xAE,0xEB,0xA4,0xDE,0x9D,0x78,0x6B,0x0A,0x28,0xBB,0x8C,0x57,0xA5,0xAD,0xA6,
						0xD3,0x54,0xEA,0x02,0x2F,0x64,0x86,0x18,0x46,0x42,0x55,0x62,0x00,0x4E,0xE4,0x43,
						0x2C,0x8E,0xC1,0xA6,0x65,0xD4,0x3D,0x57,0x45,0xAB,0xB6,0x3A,0x93,0x76,0xF9,0x26,
						0x54,0xA7,0xD1,0xEE,0xF1,0xD6,0x77,0x85,0x78,0x70,0x4E,0xB7,0x8B,0x0A,0xFF,0x9A,
						0x8E,0xC3,0xA4,0x1A,0xC6,0x52,0xEC,0x86,0x51,0x99,0xE2,0x5F,0x04,0xF7,0x74,0x9B,
						0xBD,0x79,0x87,0x97,0xAC,0xD9,0x58,0x3A,0x9F,0x96,
		/*EMM_MOD1*/	0x01,0x0a,0x18,0xbe,0x44,0x34,0x80,0x8a,0x04,0x31,0x94,0x5e,0x6c,0xe8,0x60,0xe7,
						0x48,0x38,0xbb,0x07,0xd4,0x19,0xa0,0xe6,0x14,0xab,0xbb,0x57,0x6b,0xb9,0x90,0x90,
						0xb4,0xc4,0x24,0x58,0x50,0xb5,0xc5,0x01,0x40,0x24,0x35,0xc5,0x31,0x29,0x95,0xab,
						0x7b,0x69,0xf6,0xce,0x27,0x27,0x59,0xb9,0x54,0xbd,0x8f,0xc4,0x9f,0xec,0xa3,0x40,
						0x78,0xa6,0xff,0xe2,0x5b,0x7b,0xf6,0x79,0xa1,0xe5,0xef,0xc7,0x0e,0xda,0x59,0x7a,
						0x18,0xa7,0x19,0xa2,0x27,0x44,0x47,0xf0,0x34,0xe6,
		/*EMM_MOD2*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		/*EMM_EXP0*/	0x55,0x4A,0x2F,0x64,0x4C,0x9D,
		/*EMM_EXP1*/	0x0b,0xc0,0x92,0x0e,0x82,0xc6,
		/*ECM_EXP2*/	0,0,0,0,0,0,
		// -----------------------------
		// ------------- 00 67 ---------
		0x67, 0, 0, 0,
		/*ECM_MOD0*/	0x33,0x3F,0x3B,0x48,0xFA,0x06,0x93,0x7F,0xA9,0x71,0x25,0x19,0x2D,0xA1,0x7F,0xDB,
						0x80,0x17,0x4D,0xDA,0x07,0x08,0x85,0xA1,0x8B,0xA5,0x2B,0x92,0x9F,0x0B,0x38,0xE8,
						0xD7,0xDB,0x7B,0x03,0xB8,0xC9,0xE1,0xCF,0x7C,0xFF,0x0B,0x9F,0x3D,0x2B,0x89,0xDD,
						0x2A,0x6D,0x5A,0xDD,0x61,0xF8,0x10,0xB7,0xF1,0xC4,0xE2,0xDA,0xC3,0xD4,0xFA,0x1D,
						0x57,0xAE,0x22,0x66,0xCD,0x32,0x35,0xD7,0x24,0xF5,0x3A,0x3D,0x6F,0x01,0x0A,0x13,
						0x7A,0xDF,0x21,0x26,0xCA,0x28,0xC1,0x17,0x6F,0xB1,
		/*ECM_MOD1*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		/*ECM_MOD2*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	    /*ECM_EXP0*/	0xB3,0x67,0xAF,0xA2,0x54,0xE5,
	 	/*ECM_EXP1*/	0,0,0,0,0,0,
		/*ECM_EXP2*/	0,0,0,0,0,0,
		/*EMM_MOD0*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		/*EMM_MOD1*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		/*EMM_MOD2*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		/*EMM_EXP0*/	0,0,0,0,0,0,
		/*EMM_EXP1*/	0,0,0,0,0,0,
		/*ECM_EXP2*/	0,0,0,0,0,0,
	#endif

	#ifdef _CYFRA_SUPPORT_
		// -----------------------------
		// ------------- 00 65 ---------
		0x65, 0, 0, 0,
		/*ECM_MOD0*/
						0xD7,0x2B,0xF9,0x6B,0xED,0xEA,0xE1,0xFB,0x3F,0xC9,0x1A,0x60,0xF1,0x44,0x3B,0x02,
						0x39,0xDC,0x8F,0xF5,0x0D,0xBA,0x0A,0xA8,0xB3,0xDA,0x56,0x91,0xC1,0xA1,0xF4,0x7E,
						0x5A,0xD8,0x9F,0x4E,0xFD,0xD4,0xBE,0x42,0x1B,0x77,0x27,0x5D,0x7D,0x0E,0xC0,0xF7,
						0x34,0xC3,0x2F,0x75,0x1C,0x3C,0x1E,0x25,0xFD,0xC3,0x03,0x41,0x08,0xC4,0xFF,0x6D,
						0x23,0xDF,0x6F,0x19,0x90,0xAB,0x55,0x9E,0x86,0xB6,0xFB,0xCB,0x3D,0xE6,0x09,0xA6,
						0xDC,0xD3,0x70,0x94,0x85,0xD5,0xB5,0xD2,0xA9,0x8F,
		/*ECM_MOD1*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		/*ECM_MOD2*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	    /*ECM_EXP0*/	0xF3,0xF6,0xC4,0xDB,0x90,0xEE,
	 	/*ECM_EXP1*/	0,0,0,0,0,0,
		/*ECM_EXP2*/	0,0,0,0,0,0,
		/*EMM_MOD0*/	0x5D,0x10,0x34,0xB6,0x45,0x51,0x09,0x3A,0x5D,0xAD,0x9A,0x55,0x19,0xDF,0xB1,0x14,
						0xA5,0x17,0xBD,0x42,0x0D,0x76,0x52,0x89,0x65,0x0A,0xC8,0xB4,0x51,0x02,0x3C,0xEB,
						0x84,0xDF,0xD2,0x29,0x14,0x9F,0x95,0x02,0xDF,0xB5,0x5A,0x4A,0xD2,0xED,0xFC,0xBD,
						0x20,0x31,0x34,0x8A,0x63,0x3A,0x2F,0x8C,0xB8,0x0D,0x51,0x09,0xBB,0x58,0xCD,0x08,
						0x61,0x02,0xEF,0xAF,0x0B,0x01,0x31,0x32,0xB5,0x82,0x41,0x9D,0xC3,0xAE,0xDC,0xDB,
						0x22,0x3F,0x8A,0xFE,0x4B,0xF4,0x63,0x7D,0x34,0xAE,
		/*EMM_MOD1*/	0xB1,0x77,0x4F,0x16,0xAC,0x5E,0x20,0x67,0x38,0x48,0xFF,0x83,0x3B,0x33,0xA7,0xA5,
						0x8F,0xC7,0xCC,0xEE,0xC1,0x89,0x1E,0xA4,0xB1,0x2A,0xFF,0x69,0xAC,0xFA,0x74,0x4C,
						0xA0,0x50,0x16,0x06,0x7D,0x56,0x83,0xE4,0xE6,0x94,0x75,0x2C,0xA0,0x1D,0x6D,0x43,
						0xC2,0x16,0xBD,0x1A,0x87,0x79,0xBD,0xF1,0x1D,0x02,0xB2,0x03,0x88,0x02,0x31,0x05,
						0x93,0x1E,0xA4,0xAB,0x52,0xC5,0xDC,0x91,0xC2,0x92,0x20,0x86,0x79,0x38,0x4D,0xDE,
						0xD4,0x53,0x70,0xB5,0x9B,0x2E,0x0D,0xD1,0x50,0x82,
		/*EMM_MOD2*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		/*EMM_EXP0*/	0x8B,0xFE,0x61,0xBF,0x76,0xB3,
		/*EMM_EXP1*/	0x49,0xFE,0xA1,0x15,0xE4,0xC9,
		/*ECM_EXP2*/	0,0,0,0,0,0,
	#endif

	#ifdef _CANAL_NL_SUPPORT_
		// -----------------------------
		// ------------- 00 6A ---------
		0x6A,0x6B,0x6C,0x6D,
		/*ECM_MOD0*/	0xD7,0xE0,0x80,0xBD,0xEA,0xA9,0xA0,0xB6,0xE7,0xE8,0x15,0x77,0xDC,0x50,0xD5,0x05,
						0x60,0x6E,0x24,0x39,0x84,0x01,0xE9,0x23,0x8E,0xD4,0xCC,0x5F,0x6A,0x9D,0xB8,0xCB,
						0x48,0x5A,0xC0,0x89,0x25,0xC8,0x90,0x31,0x51,0x4A,0x55,0x61,0x8E,0xDD,0x04,0x3E,
						0xA6,0x80,0xBD,0x32,0x26,0x1A,0x1C,0x06,0x61,0xC1,0x9D,0x20,0xEC,0x18,0x9C,0x47,
						0x35,0xAB,0x52,0x49,0xC6,0x2E,0xA4,0x37,0x7B,0x1C,0x09,0x45,0x93,0x21,0x6E,0x42,
						0x92,0x1A,0x74,0x0F,0xEB,0xFC,0xBB,0x10,0x15,0xC5,
		/*ECM_MOD1*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		/*ECM_MOD2*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		/*ECM_EXP0*/	0x91,0xB3,0xC4,0x6D,0x03,0x86,
		/*ECM_EXP1*/	0,0,0,0,0,0,
		/*ECM_EXP2*/	0,0,0,0,0,0,
		/*EMM_MOD0*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		/*EMM_MOD1*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		/*EMM_MOD2*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		/*EMM_EXP0*/	0,0,0,0,0,0,
		/*EMM_EXP1*/	0,0,0,0,0,0,
		/*ECM_EXP2*/	0,0,0,0,0,0,
	#endif

	#ifdef _CANAL_FR_SUPPORT_
		// -----------------------------
		// ------------- 00 80 ---------
		0x80, 0, 0, 0,
		/*ECM_MOD0*/0x97,0x5C,0x9B,0xDD,0xF2,0x5B,0x70,0x20,0x3A,0xF1,0x7E,0x3D,0x66,0x8A,0x1D,0x23,
						0xE1,0x8F,0x76,0xC2,0x33,0xAC,0xED,0x9C,0x79,0x64,0x0E,0x9B,0xA0,0x1E,0x83,0xAE,
						0xAA,0x4F,0x2A,0x04,0x2D,0x82,0x18,0x84,0xBF,0xB4,0x79,0xAD,0xF0,0x71,0x81,0x0C,
						0xAD,0x59,0xBC,0x61,0x10,0x1F,0x5B,0x6C,0x50,0xCC,0xC3,0x98,0xB7,0x7E,0x36,0x27,
						0x3A,0xA2,0x28,0x5E,0xE0,0x3A,0xE8,0xFE,0x98,0x96,0x79,0x58,0x75,0x71,0x52,0x68,
						0x90,0x75,0x3E,0xC1,0xB2,0xAB,0x9F,0x6D,0xEB,0xD9,

		/*ECM_MOD1*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		/*ECM_MOD2*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		/*ECM_EXP0*/	0x89,0xE9,0x9D,0xB5,0xC1,0xA8,
		/*ECM_EXP1*/	0,0,0,0,0,0,
		/*ECM_EXP2*/	0,0,0,0,0,0,
		/*EMM_MOD0*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		/*EMM_MOD1*/0x79,0xD8,0x19,0x5B,0x41,0x29,0xBC,0x28,0x28,0x37,0x2A,0x37,0xD0,0xB8,0xBD,0xF4,
						0xF9,0x31,0xE5,0xF4,0x8C,0x27,0x69,0xD4,0x95,0xAA,0x9C,0x03,0x4F,0x36,0xB4,0x8E,
						0xB3,0xB8,0xBF,0x64,0x9E,0xCD,0xB6,0x32,0xD2,0xF7,0x8E,0xC2,0xF2,0xE3,0xEC,0xCD,
						0x92,0xCC,0x17,0x40,0x31,0x95,0xF1,0x3B,0x62,0xAA,0xA7,0x12,0xD6,0xE6,0x72,0xA9,
						0x73,0x81,0xCC,0x31,0x00,0xAB,0x0B,0xA1,0x1C,0xDE,0x32,0x01,0x51,0xC2,0x21,0x3F,
						0x30,0x13,0x2B,0x8D,0xC2,0x99,0x3F,0x02,0x4A,0xB8,
		/*EMM_MOD2*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		/*EMM_EXP0*/	0,0,0,0,0,0,
		/*EMM_EXP1*/	0x0F,0xCC,0x79,0x1F,0xB0,0x91,
		/*ECM_EXP2*/	0,0,0,0,0,0,
		// -----------------------------
		// ------------- 00 81 ---------
		0x81, 0, 0, 0,
		/*ECM_MOD0*/0x99,0xB0,0x22,0x6C,0x68,0x00,0xB1,0x82,0x43,0x78,0xE2,0x37,0x28,0x69,0x62,0xCE,
						0x37,0x07,0x75,0x33,0x64,0x84,0x73,0x8F,0x9A,0xBA,0x77,0x94,0x73,0xBC,0x85,0xF3,
						0xED,0x02,0x18,0x7C,0x15,0x55,0x0E,0x29,0x20,0x66,0xAC,0x2A,0x02,0x04,0xC2,0x79,
						0x19,0xE9,0x7F,0x7F,0xD4,0x62,0xBD,0x31,0x2F,0x6B,0x4B,0x82,0x53,0x0F,0xE5,0xAB,
						0xCE,0x89,0xCD,0xCD,0x39,0x48,0x57,0x69,0x8B,0xA2,0x1E,0x22,0xF5,0xC4,0x4C,0xA6,
						0xE6,0x3A,0x1D,0xB4,0xC7,0x16,0xC8,0x88,0x38,0xD0,

		/*ECM_MOD1*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		/*ECM_MOD2*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		/*ECM_EXP0*/	0x39,0x9E,0x66,0x5B,0x8A,0x85,
		/*ECM_EXP1*/	0,0,0,0,0,0,
		/*ECM_EXP2*/	0,0,0,0,0,0,
		/*EMM_MOD0*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		/*EMM_MOD1*/0xCB,0x41,0x58,0xDA,0xF9,0x65,0xCC,0xF1,0x0F,0xFF,0x82,0x5C,0xBE,0xE5,0xAE,0x65,
						0x2B,0xD7,0x53,0xAC,0x56,0x56,0xD1,0x06,0xD6,0x45,0x57,0xA2,0x09,0xDA,0xEE,0x3C,
						0x4F,0xE2,0xA3,0xD8,0xE9,0xEC,0xF7,0xC2,0x59,0x39,0xCB,0x5D,0x51,0x76,0x37,0x13,
						0x14,0x9F,0xA7,0xF0,0x27,0x76,0x4A,0xA0,0xFF,0x57,0x79,0xA1,0xB8,0x32,0xC4,0x2F,
						0x59,0x07,0x5E,0x99,0x74,0xC2,0x36,0x7D,0x91,0xC1,0xBA,0xEB,0x82,0x34,0x9A,0xDB,
						0x6D,0xEC,0xCB,0xD5,0x35,0xC8,0x72,0x5A,0x63,0x9F,
		/*EMM_MOD2*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		/*EMM_EXP0*/	0,0,0,0,0,0,
		/*EMM_EXP1*/	0x7D,0xEB,0xCC,0x21,0x10,0x94,
		/*ECM_EXP2*/	0,0,0,0,0,0,
		// -----------------------------
		// ------------- 00 82 ---------
		0x82, 0, 0, 0,
		/*ECM_MOD0*/0x59,0xE5,0x77,0x94,0x85,0x93,0x64,0x94,0xA1,0xF0,0xE4,0x26,0xD1,0x41,0x83,0x70,
						0xD4,0x34,0x40,0xE6,0x15,0xF4,0x32,0x0E,0xC3,0x2B,0x78,0xCE,0xF6,0xC9,0xC0,0x73,
						0xA5,0x52,0xD5,0xC4,0x70,0xFA,0x73,0xEB,0xEC,0xF4,0xAD,0xE1,0x64,0x84,0x52,0xD5,
						0x2E,0x4B,0xAC,0x71,0x2F,0xE3,0x18,0x8B,0x76,0xC9,0xD4,0xFC,0x92,0xC9,0x86,0x4D,
						0x10,0xF7,0x74,0x09,0x9A,0xA2,0xAE,0xD6,0x4F,0x22,0x44,0xAB,0x68,0xA0,0x20,0x65,
						0xCB,0xA3,0x8D,0xB3,0xDB,0xB0,0xF7,0xDC,0x4B,0x95,

		/*ECM_MOD1*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		/*ECM_MOD2*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		/*ECM_EXP0*/	0x7B,0x79,0xC9,0x37,0x3E,0xA2,
		/*ECM_EXP1*/	0,0,0,0,0,0,
		/*ECM_EXP2*/	0,0,0,0,0,0,
		/*EMM_MOD0*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		/*EMM_MOD1*/0x95,0x41,0xAD,0xE6,0x2C,0xE1,0xFF,0xEF,0xF8,0x97,0xD9,0xE9,0x67,0xC4,0x0A,0xF6,
						0xA8,0x2F,0xB2,0x3A,0x63,0xFB,0xBA,0xA6,0xF1,0xBF,0xD4,0x80,0x74,0x1A,0x24,0x0A,
						0x6E,0xDD,0x62,0x2A,0x5C,0xAF,0x62,0xCA,0x11,0x19,0x85,0xD9,0x5A,0x02,0xA5,0x52,
						0xB6,0x73,0x66,0xD9,0xA6,0x45,0xC1,0xA5,0x52,0x4D,0x50,0x62,0xBA,0xFE,0x64,0x94,
						0xB2,0x13,0x2A,0x0A,0x93,0xF8,0x52,0x51,0xF2,0x9F,0x7D,0xD9,0xB2,0x62,0x05,0x80,
						0x93,0xD3,0x66,0x48,0x0B,0xE7,0xA9,0x94,0xFA,0xBC,
		/*EMM_MOD2*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		/*EMM_EXP0*/	0,0,0,0,0,0,
		/*EMM_EXP1*/	0xC3,0x12,0x54,0x65,0x9B,0xFA,
		/*ECM_EXP2*/	0,0,0,0,0,0,
		// -----------------------------
		// ------------- 00 84 ---------
		0x84, 0, 0, 0,
		/*ECM_MOD0*/0xF1,0xAF,0xF9,0xC1,0x36,0xBD,0x30,0xFA,0x2D,0xCF,0xC5,0xE4,0x26,0x54,0x5D,0x56,
						0xA9,0x15,0xD3,0x66,0x9A,0xC4,0x09,0x29,0xDB,0x50,0x16,0xD4,0x1F,0x05,0x54,0x8B,
						0x54,0xB1,0xB9,0xC6,0x48,0x24,0x3F,0x2C,0xD3,0xED,0x30,0x57,0x38,0x15,0xC3,0xF6,
						0x58,0xE4,0x41,0xCA,0x66,0x72,0xFB,0x7B,0xA6,0x1F,0x10,0x40,0xBD,0x5C,0x87,0xCF,
						0x63,0xC8,0xC0,0xA9,0xAC,0x58,0x50,0x47,0xBC,0x8B,0x17,0x1A,0xC8,0xC3,0x49,0x37,
						0xF0,0x55,0x97,0x24,0x3D,0xE7,0xE5,0x09,0x2B,0xA7,

		/*ECM_MOD1*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		/*ECM_MOD2*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		/*ECM_EXP0*/	0x85,0xCC,0x7C,0xB7,0x8C,0x81,
		/*ECM_EXP1*/	0,0,0,0,0,0,
		/*ECM_EXP2*/	0,0,0,0,0,0,
		/*EMM_MOD0*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		/*EMM_MOD1*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		/*EMM_MOD2*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		/*EMM_EXP0*/	0,0,0,0,0,0,
		/*EMM_EXP1*/	0,0,0,0,0,0,
		/*ECM_EXP2*/	0,0,0,0,0,0,
		// -----------------------------
		// ------------- 00 86 ---------
		0x86, 0, 0, 0,
		/*ECM_MOD0*/0x0B,0x34,0x8E,0x67,0xD1,0x06,0x30,0x0F,0x18,0x66,0x85,0xB0,0xF6,0x57,0x6B,0x83,
						0x47,0xA0,0xDE,0xD7,0x6A,0xBF,0x4F,0xDA,0xDE,0x29,0xDA,0x38,0x52,0x6E,0x53,0xA4,
						0x27,0xDE,0xA9,0x32,0x63,0x01,0x45,0x52,0xAD,0x0F,0xC9,0xB5,0x31,0xF3,0x25,0x77,
						0x75,0x14,0x0D,0x37,0x7B,0x4D,0x5F,0x8D,0x56,0xEF,0xFD,0xD5,0xAE,0x40,0xDD,0xB1,
						0xC5,0x21,0xF7,0xF9,0xB3,0xC9,0xD7,0xD3,0x00,0xE2,0x79,0x9C,0xC1,0x88,0xB7,0xB3,
						0x51,0xBC,0xEF,0xC7,0x48,0x43,0x5C,0x73,0x1B,0x9C,

		/*ECM_MOD1*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		/*ECM_MOD2*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		/*ECM_EXP0*/	0xAF,0x8B,0x43,0x6A,0x60,0xAE,
		/*ECM_EXP1*/	0,0,0,0,0,0,
		/*ECM_EXP2*/	0,0,0,0,0,0,
		/*EMM_MOD0*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		/*EMM_MOD1*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		/*EMM_MOD2*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		/*EMM_EXP0*/	0,0,0,0,0,0,
		/*EMM_EXP1*/	0,0,0,0,0,0,
		/*ECM_EXP2*/	0,0,0,0,0,0,
	#endif

	#ifdef _SKYITALIA_SUPPORT_
		// -----------------------------
		// ------------- 00 70 ---------
		0x70, 0, 0, 0,
		/*ECM_MOD0*/0x4B,0xD5,0x10,0x54,0xC7,0xA7,0xA1,0x2C,0x5E,0x47,0xFF,0x49,0xC7,0x96,0xD2,0x7B,
						0xC7,0x1C,0x0A,0xEC,0xB0,0x56,0xE1,0xA9,0xEE,0xC0,0xCE,0xB2,0x9F,0x34,0x62,0xE4,
						0xA2,0x11,0x6A,0x87,0xC3,0xAC,0x53,0x23,0xCF,0xA3,0x13,0xB2,0x25,0xEB,0xC4,0x1A,
						0xD8,0x8E,0x54,0xB5,0xC8,0x05,0x39,0x87,0x9E,0x22,0x21,0xF6,0xAB,0xC8,0x0F,0x3C,
						0x5A,0x43,0x4A,0x39,0xA8,0x54,0xB1,0x9B,0x16,0xB8,0xB1,0x58,0x6F,0x66,0x22,0x20,
						0xFF,0x31,0x1A,0x88,0x5A,0xE4,0xCD,0x9C,0x2B,0x86,
		/*ECM_MOD1*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		/*ECM_MOD2*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		/*ECM_EXP0*/	0x0F,0x7A,0x83,0x0E,0x12,0xF8,
		/*ECM_EXP1*/	0,0,0,0,0,0,
		/*ECM_EXP2*/	0,0,0,0,0,0,
		/*EMM_MOD0*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		/*EMM_MOD1*/0xF3,0xD3,0x54,0x7A,0x3F,0x30,0x8C,0x05,0x53,0xAA,0x24,0x6D,0x1E,0x5C,0x20,0x66,
						0x5E,0x2B,0x61,0x8D,0xBA,0x37,0x24,0x06,0x70,0xBB,0x66,0x72,0x7E,0x50,0x83,0x8C,
						0xBA,0x7D,0x48,0x49,0x93,0x0C,0x18,0xF4,0x35,0x5C,0x74,0x18,0xE3,0xA2,0xAD,0x14,
						0xE9,0x60,0x18,0x6F,0x48,0x65,0xC9,0x49,0x84,0x9A,0x9D,0xEA,0x35,0xBE,0xB8,0x45,
						0x10,0xF8,0x99,0x1F,0xF5,0x55,0x45,0x37,0x4A,0x05,0x44,0xBC,0x71,0x5F,0x30,0x51,
						0x08,0xE8,0x91,0x61,0x75,0x3C,0x2A,0xE3,0x34,0x95,
		/*EMM_MOD2*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		/*EMM_EXP0*/	0,0,0,0,0,0,
		/*EMM_EXP1*/	0x4D,0x38,0x9F,0xED,0xD4,0xB6,
		/*ECM_EXP2*/	0,0,0,0,0,0,
		// -----------------------------
		// ------------- 00 71 ---------
		0x71, 0, 0, 0,
		/*ECM_MOD0*/0xDF,0x9C,0x7A,0xA8,0xD8,0x8C,0xC9,0xF8,0x24,0x78,0xA9,0x4C,0x79,0xBC,0x5F,0xBC,
						0x34,0xB9,0x51,0xAB,0xF8,0x1E,0xED,0xCF,0xE9,0x31,0xA5,0xAA,0x72,0x58,0x32,0x1C,
						0x4C,0x4E,0x28,0x16,0x87,0x29,0xC4,0x65,0x26,0xA6,0x92,0x83,0xAA,0x52,0xD2,0xF5,
						0xC6,0x85,0xE2,0xEA,0x20,0x03,0x28,0x1B,0x19,0x77,0x7C,0xA2,0xD1,0x12,0x5C,0x02,
						0xA5,0x51,0x09,0x84,0x85,0xF2,0x9A,0xD6,0x6E,0xBE,0xAE,0x8C,0xFA,0x64,0x84,0x33,
						0xAE,0xE7,0xC4,0x5F,0x1B,0xEA,0x76,0x8C,0xE7,0x93,
		/*ECM_MOD1*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		/*ECM_MOD2*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		/*ECM_EXP0*/	0x75,0xD1,0x8A,0x7E,0x31,0x9E,
		/*ECM_EXP1*/	0,0,0,0,0,0,
		/*ECM_EXP2*/	0,0,0,0,0,0,
		/*EMM_MOD0*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		/*EMM_MOD1*/0xA3,0x07,0x71,0x64,0xD6,0xDA,0x00,0x55,0xED,0xCD,0xEC,0x3C,0x40,0x06,0x72,0xAC,
						0xD3,0xB5,0xFC,0x3A,0xA4,0x7B,0x13,0x06,0xBB,0x9F,0x0C,0xB0,0xF2,0x9C,0x7D,0x0D,
						0x03,0xF3,0x7C,0xCD,0x95,0x06,0xCC,0x89,0xF3,0x68,0xFC,0x41,0x9A,0x69,0x25,0x4E,
						0x65,0x71,0x05,0x0E,0xA4,0xB1,0x82,0xBD,0xD4,0x35,0x5D,0x91,0xB5,0xD2,0xB2,0x1E,
						0x36,0x23,0xF9,0xBB,0x91,0x9E,0xB6,0x5E,0x1C,0xB5,0xC0,0x9C,0x78,0x5F,0x20,0x20,
						0x35,0x14,0xE5,0xDA,0x94,0xA7,0x7E,0x61,0x51,0xAA,
		/*EMM_MOD2*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		/*EMM_EXP0*/	0,0,0,0,0,0,
		/*EMM_EXP1*/	0x03,0x64,0x94,0x7A,0x4E,0x94,
		/*ECM_EXP2*/	0,0,0,0,0,0,
		// -----------------------------
		// ------------- 00 72 ---------
		0x72, 0, 0, 0,
		/*ECM_MOD0*/0x87,0x6A,0x95,0x3C,0xA6,0x24,0x48,0x9F,0x6E,0x69,0x52,0xF6,0xE2,0xD8,0x25,0x43,
						0xB5,0x6C,0xAA,0x70,0xC9,0x13,0x26,0xF9,0xB9,0x86,0x9D,0x7E,0x53,0xAB,0xF1,0x4D,
						0xEA,0xBE,0xAE,0x8C,0x77,0xD2,0xDC,0x91,0x89,0x4F,0xEA,0x98,0xA7,0xF2,0xCC,0x62,
						0xA6,0xED,0x39,0xA6,0x10,0x56,0x3B,0x8F,0x55,0x78,0x9F,0x15,0xC1,0x08,0x2D,0xC2,
						0xE9,0x53,0xA7,0xF4,0x9C,0x82,0xA8,0xCA,0x0D,0x9E,0xB8,0xD9,0xC7,0x2F,0x03,0xDC,
						0xDE,0xA4,0xA5,0xC7,0x6A,0xA1,0xD8,0xEC,0xB2,0xAC,
		/*ECM_MOD1*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		/*ECM_MOD2*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		/*ECM_EXP0*/	0x71,0x7D,0x4A,0x88,0xEB,0xED,
		/*ECM_EXP1*/	0,0,0,0,0,0,
		/*ECM_EXP2*/	0,0,0,0,0,0,
		/*EMM_MOD0*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		//          	0x41,0x16,0xB2,0xA8,0x3A,0x29,0xF1,0xEB,0xF3,0xB3,0x4B,0x63,0x03,0x4F,0x14,0x90,
		/*EMM_MOD1*/0x4F,0x16,0xB2,0xA8,0x3A,0x29,0xF1,0xEB,0xF3,0xB3,0x4B,0x63,0x03,0x4F,0x14,0x90,
						0x65,0x40,0x94,0x3B,0x51,0xB8,0xE8,0xD0,0x22,0x54,0x60,0x2B,0xE5,0xC3,0xAB,0x6F,
						0xC9,0x33,0x8E,0x0E,0x0A,0xFE,0x73,0xC4,0x76,0xAD,0xF5,0x9B,0x0A,0xE5,0x15,0x73,
						0xCC,0x6A,0x0B,0x79,0xA3,0x57,0xF0,0x21,0xB8,0xB3,0x39,0x4C,0x75,0x2A,0xF8,0x68,
						0x4D,0x25,0x8F,0x74,0x16,0x0D,0x76,0xF1,0x37,0xE1,0x55,0x25,0x42,0xD9,0xC1,0xF6,
						0x12,0xAA,0x28,0xE9,0xE8,0xEB,0xE9,0xE8,0x86,0x85,
		/*EMM_MOD2*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
							0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		/*EMM_EXP0*/	0,0,0,0,0,0,
		/*EMM_EXP1*/	0x73,0x56,0x66,0x33,0xB8,0x94,
		/*ECM_EXP2*/	0,0,0,0,0,0,
	#endif
	// -----------------------------
	// ------------- RESERVED------
	0,0,0,0,
	/*ECM_MOD0*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	/*ECM_MOD1*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	/*ECM_MOD2*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	/*ECM_EXP0*/	0,0,0,0,0,0,
	/*ECM_EXP1*/	0,0,0,0,0,0,
	/*ECM_EXP2*/	0,0,0,0,0,0,
	/*EMM_MOD0*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	/*EMM_MOD1*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	/*EMM_MOD2*/	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
						0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	/*EMM_EXP0*/	0,0,0,0,0,0,
	/*EMM_EXP1*/	0,0,0,0,0,0,
	/*ECM_EXP2*/	0,0,0,0,0,0,
};

#ifdef _SKYITALIA_SUPPORT_
	static uint8_t seka2_cw70XT[16] =
		{ 0x07,0x17,0x3F,0x5E,0x6A,0xF7,0xB2,0x25, 0xA6,0x97,0x6A,0xCA,0xE2,0x2F,0xC8,0x1F };
	static uint8_t seka2_cw70PT[16] =
		{ 0x01,0x00,0x02,0x04,0x03,0x07,0x05,0x06, 0x0E,0x0B,0x0D,0x0A,0x0F,0x0C,0x09,0x08 };
#endif

#ifdef _CYFRA_SUPPORT_
	static uint8_t seka2_cw65XT[16] =
		{ 0xA0,0x12,0x23,0x35,0x46,0xB0,0xDF,0xCA, 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 };
	static uint8_t seka2_cw65PT[16] =
		{ 0x05,0x04,0x06,0x07,0x03,0x00,0x01,0x02, 0x08,0x09,0x0A,0x0B,0x0C,0x0D,0x0E,0x0F };
#endif

static SEKAII_ISSUER seka2_issuer_data[MAX_SEKAII_ISSUERS] =
{
	#ifdef _DPLUS_SUPPORT_
		{
		// --- Spain ---
		/*Provis */		{0x64, 0x66, 0x67, 0x60,},
		/*sha1pad*/		0x96,
		/*sha1end*/		0x69,
		/*T1_0 9x */	seka2_64H9x_T1,
		/*T1_1 Bx*/		seka2_64HBx_T1,
		/*T1_3 Fx*/		seka2_xxHFx_T1,
		/*T2_0 9x */	seka2_64H9x_T2,
		/*T2_1 Bx*/		seka2_64HBx_T2,
		/*T2_3 Fx*/		seka2_xxHFx_T2,
		/*mask table*/	(uint8_t *)seka2_64MT_BIN,
		/*XT */			NULL,
		/*PT */			NULL,
		},
	#endif

	#ifdef _CYFRA_SUPPORT_
		{
		//---Cyfra---
		/*Provis */		{0x65, },
		/*sha1pad*/		0x96,	// 0xC1
		/*sha1end*/		0x69,	// 0x1C
		/*T1_0 9x */	seka2_65H9x_T1,
		/*T1_1 Bx*/		seka2_65HBx_T1,
		/*T1_3 Fx*/		seka2_65HFx_T1,
		/*T2_0 9x */	seka2_65H9x_T2,
		/*T2_1 Bx*/		seka2_65HBx_T2,
		/*T2_3 Fx*/		seka2_65HFx_T2,
		/*mask table*/	(uint8_t *)seka2_65MT_BIN,
		/*XT*/			(uint8_t *)seka2_cw65XT,
		/*PT */			(uint8_t *)seka2_cw65PT,
		},
	#endif

	#ifdef _CANAL_NL_SUPPORT_
		{
		//---Cyfra---
		/*Provis */		{0x6A,0x6B,0x6C,0x6D},
		/*sha1pad*/		0xA3,	// 0xA3
		/*sha1end*/		0x3A,	// 0x3A
		/*T1_0 9x */	seka2_6AH9x_T1,
		/*T1_1 Bx*/		seka2_6AHBx_T1,
		/*T1_3 Fx*/		seka2_6AHFx_T1,
		/*T2_0 9x */	seka2_6AH9x_T2,
		/*T2_1 Bx*/		seka2_6AHBx_T2,
		/*T2_3 Fx*/		seka2_6AHFx_T2,
		/*mask table*/	(uint8_t *)seka2_6AMT_BIN,
		/*XT*/			(uint8_t *)NULL,
		/*PT */			(uint8_t *)NULL,
		},
	#endif

	#ifdef _CANAL_FR_SUPPORT_
		{
		/*Provis */		{0x80,},
		/*sha1pad*/		0xA1,
		/*sha1end*/		0x1A,
		/*T1_0 9x */	seka2_80H9x_T1,
		/*T1_1 Bx*/		seka2_80HBx_T1,
		/*T1_3 Fx*/		seka2_80HFx_T1,
		/*T2_0 9x */	seka2_80H9x_T2,
		/*T2_1 Bx*/		seka2_80HBx_T2,
		/*T2_3 Fx*/		seka2_80HFx_T2,
		/*mask table*/	(uint8_t *)seka2_80MT_BIN,
		/*XT*/			(uint8_t *)NULL,
		/*PT */			(uint8_t *)NULL,
		},
		{
		/*Provis */		{0x81,},
		/*sha1pad*/		0xA1,
		/*sha1end*/		0x1A,
		/*T1_0 9x */	seka2_81H9x_T1,
		/*T1_1 Bx*/		seka2_81HBx_T1,
		/*T1_3 Fx*/		seka2_81HFx_T1,
		/*T2_0 9x */	seka2_81H9x_T2,
		/*T2_1 Bx*/		seka2_81HBx_T2,
		/*T2_3 Fx*/		seka2_81HFx_T2,
		/*mask table*/	(uint8_t *)seka2_81MT_BIN,
		/*XT*/			(uint8_t *)NULL,
		/*PT */			(uint8_t *)NULL,
		},
	#endif


	#ifdef _SKYITALIA_SUPPORT_
		{
		//---Italy---
		/*Provis */		{0x70, 0x71, 0x72, 0x73,},
		/*sha1pad*/		0xA1,
		/*sha1end*/		0x1A,
		/*T1_0 9x */	seka2_70H9x_T1,
		/*T1_1 Bx*/		seka2_70HBx_T1,
		/*T1_3 Fx*/		seka2_70HFx_T1,
		/*T2_0 9x */	seka2_70H9x_T2,
		/*T2_1 Bx*/		seka2_70HBx_T2,
		/*T2_3 Fx*/		seka2_70HFx_T2,
		/*mask table*/	(uint8_t *)seka2_70MT_BIN,
		/*XT*/			(uint8_t *)seka2_cw70XT,
		/*PT */			(uint8_t *)seka2_cw70PT,
		},
	#endif

	{
		// --- RESERVED ---
		/*Provis */		{0x0, 0x0, 0x0, 0x0,},
		/*sha1pad*/		0x0,
		/*sha1end*/		0x0,
		/*T1_0 9x */	NULL,
		/*T1_1 Bx*/		NULL,
		/*T1_3 Fx*/		NULL,
		/*T2_0 9x */	NULL,
		/*T2_1 Bx*/		NULL,
		/*T2_3 Fx*/		NULL,
		/*mask table*/	NULL,
		/*XT */			NULL,
		/*PT */			NULL,
	},
};
//
//
//
static uint16_t		seka_prid;
static SEKAII_PROVI 	*seka2_provi;
static SEKAII_ISSUER	*seka2_issuer;

static BIGNUM 			er_ecmMod, er_ecmExp;
static BIGNUM 			er_n51Mod, er_n51Exp;
static int16_t			er_KFOUND;
static uint32_t		er_KPRID;
static uint8_t			er_KNR;
static uint8_t			er_KKEY[16];
// reader_common.c
extern int32_t rdr_RSA_decrypt(struct s_reader *reader, uint8_t *out, uint8_t *in, int32_t n, BIGNUM *exp, BIGNUM *mod, int32_t LE);
//======================================================================
//======================================================================
//======================================================================
//======================================================================
//======================================================================
//======================================================================
int
xseka_sct_payload(uint8_t *d, uint8_t **payload)
{
	int l;

	switch (_seka_tid_(d))
	{
		case 0x80:
		case 0x81: l=sizeof(SEKA_ECM); 	break;
		case 0x82: l=sizeof(SEKA_EMM_U); break;
		case 0x84: l=sizeof(SEKA_EMM_S); break;
		default: return -1;
    }
	if (payload) *payload=&d[l];
	return (SCT_LEN(d)-3-l+3);
}

int
xseka_sct_sysmode(uint8_t *d)
{
	switch (_seka_tid_(d))
	{
		case 0x80:
		case 0x81: return ((SEKA_ECM *)  d)->sm; break;
		case 0x82: return ((SEKA_EMM_U *)d)->sm; break;
		case 0x84: return ((SEKA_EMM_S *)d)->sm; break;
		default: return -1;
	}
}

int
xseka_sct_keynr(uint8_t *d)
{
	switch (_seka_tid_(d))
	{
		case 0x80:
		case 0x81: return ((SEKA_ECM *)  d)->keynr; break;
		case 0x82: return ((SEKA_EMM_U *)d)->keynr; break;
		case 0x84: return ((SEKA_EMM_S *)d)->keynr; break;
		default: return -1;
	}
}

uint8_t *
xseka_sct_provp(uint8_t *d)
{
	switch (_seka_tid_(d))
	{
		case 0x80:
		case 0x81: return ((SEKA_ECM *)  d)->id;
		case 0x82: return ((SEKA_EMM_U *)d)->id;
		case 0x84: return ((SEKA_EMM_S *)d)->id;
	}
	return 0;
}

uint8_t *
xseka_sct_emmaddr(uint8_t *d)
{
	switch (_seka_tid_(d))
	{
		case 0x80:
		case 0x81: return 0;
		case 0x82: return ((SEKA_EMM_U *)d)->ua;
		case 0x84: return ((SEKA_EMM_S *)d)->sa;
	}
	return 0;
}

int
xseka_sct_prid(uint8_t *d)
{
  uint8_t *id = xseka_sct_provp(d);

  return (id ? (id[0] << 8) + id[1] : -1);
}
//======================================================================
//======================================================================
//======================================================================
//======================================================================
//======================================================================
//======================================================================
//======================================================================
//======================================================================
//======================================================================
//----------------------------------------------------------------------
//----------------------------------------------------------------------
//----------------------------------------------------------------------
//----------------------------------------------------------------------
//----------------------------------------------------------------------
//----------------------------------------------------------------------
//----------------------------------------------------------------------
//----------------------------------------------------------------------
//----------------------------------------------------------------------
static void
xseka_Fase(uint8_t *D, uint8_t *key, uint8_t *T1, uint8_t *T2)
{
	// Modifica 4 bytes en D con 4 bytes de clave en k

	uint8_t l,dt; // paso 1
	for (l=0;l<4;++l) D[l]^=key[l];  // paso 2
	for (l=0;l<4;++l) D[l] =T1[D[l]];
	for (l=6;l>3;--l)
	{
		D[(l+2)&3]^=D[(l+1)&3];
		dt=(_seka_sn8_(D[(l+1)&3])+D[l&3])&0xff;
		D[l&3]=T2[dt];
	}
	for (l=3;l>0;--l)
	{
		D[(l+2)&3]^=D[(l+1)&3];
		D[l&3]=T1[(_seka_sn8_(D[(l+1)&3])+D[l&3])&0xff];
	}
	D[2]^=D[1];
	D[1]^=D[0];
}


void
xseka_Decrypt(uint8_t *d, uint8_t *key, uint8_t *T1, uint8_t *T2)
{
	// k = clave de 128 bits (16 bytes),
	// d = datos de 64 bits (8 bytes)
	uint8_t i,j,l,C,dt,D[4];
	uint8_t kk[16];

	for (i=0;i<16;++i) kk[i]=key[i]; // 16 rondas
	// preparacion de la clave
	C=0xff;
	for (j=0;j<4;++j)
	{
		for (i=0;i<16;++i)
		{
			if ((i&3)==0) ++C;
			kk[i]^=T1[kk[(15+i)&0xf]^kk[(i+1)&0xf]^C];
		}
	} // manipulacion de los datos
	j=0; // 16 rondas
	for (i=0;i<16;++i)
	{
		for (l=0;l<4;++l) D[l]=d[l+4]; // Copia d5..d8 a D1..D4
		j=(j+12)&0xf; // selecciona clave apropiada
		xseka_Fase(D,&kk[j],T1,T2); // modifica D con clave pertinente
		// paso 3
		for (l=0;l<4;++l)
		{ // modifica d bajo
			d[l]^=T2[D[seka_TD[l]]]; // paso 4
		}
		for (l=3;l!=0xff;--l)
		{ // modifica k usado
			kk[j+l]^=T1[kk[(j+l+1)&0xf]^kk[(j+l+15)&0xf]^(15-i)];
		}
		if (i<15)
		{ // intercambia d altos y bajos
			for (l=0;l<4;++l)
			{
				dt=d[l];d[l]=d[4+l];d[4+l]=dt;
			}
		}
	}
}


void
xseka_Encrypt(uint8_t *d, uint8_t *key, uint8_t *T1, uint8_t *T2)
{
	// Rutina de encriptacion, no modifica la clave
	/* k=clave de 128 bits (16 bytes), d=datos de 64 bits (8 bytes) */
	uint8_t i,j,l,dt,D[4],kk[16];

	// primero hace copia de la clave
	for (i=0;i<16;++i) kk[i]=key[i]; // 16 rondas

	for (j=i=0;i<16;++i,j=(j+4)&0xf)
	{
		// paso 1
		for (l=0;l<4;++l)
		{
			kk[j+l] ^= T1[kk[(j+l+1)&0xf]^kk[(j+l+15)&0xf]^i];
		}
		if (i>0)
		{ // intercambia d altos y bajos
			for (l=0;l<4;++l)
			{
				dt=d[l]; d[l]=d[4+l]; d[4+l]=dt;
			}
		}
		for ( l=0; l<4; ++l) D[l]=d[l+4]; // Copia d5..d8 a D1..D4
		xseka_Fase(D, &kk[j],T1,T2); // modifica D con clave pertinente
		// paso 2
		for (l=0;l<4;++l)
		{ // modifica d bajo
			d[l]^=T2[D[seka_TD[l]]];
		}
	}
}


void
xseka_calc_signatures(uint8_t *buff, int len, uint8_t *signature, uint8_t *key, uint8_t *T1, uint8_t *T2)
{
	int i, j;

	memset(signature,0,8);
	for(i=0; i<len; i+=8)
	{
		for (j=0; j<8 && (i+j)<len; j++) signature[j] ^= buff[i+j];
		xseka_Encrypt(signature,key,T1,T2);
	}
}


void
xseka_xxor(uint8_t *dst, int len, uint8_t *src1, uint8_t *src2)
{
	while (len-- > 0) *dst++ = (*src1++)^(*src2++);
}


void
xseka_swap8_4(uint8_t *dst)
{
	uint8_t temp[4];

	memcpy(temp,dst,4);
	memcpy(dst,&dst[4],4);
	memcpy(&dst[4],temp,4);
}


//----------------------------------------------------------------------
//----------------------------------------------------------------------
//----------------------------------------------------------------------
//----------------------------------------------------------------------
//----------------------------------------------------------------------
//----------------------------------------------------------------------
//----------------------------------------------------------------------

static SEKAII_PROVI *
xseka_getSeka2provi(uint16_t ident)
{
	SEKAII_PROVI *provi;
	int	i, j;

	// юс╫ц╥н....
	if (ident == 0x00) return 0;
	if (ident == 0x60) ident = 0x64;

	provi = (SEKAII_PROVI *)seka2_provi_data;
	for (i=0; i<MAX_SEKAII_PRS; i++)
	{
		for (j=0; j<MAX_SEKA_PROV; j++)
		{
			if (provi->ident[j] == ident)
			{
				return (provi);
			}
		}
		provi++;
	}
	// ident not found in provi list
//	MYEMU_TRACE("xseka:Prov Num: %d\n", i);
	MYEMU_TRACE("xseka:ident{%04X} not found in provi list.\n", ident);
	return 0;
}

static SEKAII_ISSUER *
xseka_getSeka2issuer(uint16_t ident)
{
	SEKAII_ISSUER *issuer_p;
	int	i, j;

	if (ident == 0x00) return 0;
	issuer_p = (SEKAII_ISSUER *)seka2_issuer_data;
	for (i=0; i<MAX_SEKAII_ISSUERS; i++)
	{
		for (j=0; j<4; j++)
		{
			if (issuer_p->ident[j]==ident)
			{
				return (issuer_p);
			}

		}
		issuer_p++;
	}
	// ident not found in issuers list
	MYEMU_TRACE("xseka:ident{%04X} not found in issuers list.\n", ident);
	return 0;
}


static int
xseka_isSeka2available(uint16_t ident)
{
	// _CANAL_NL_SUPPORT_
	// _DPLUS_SUPPORT_
	// _CYFRA_SUPPORT_
#if defined(_CYFRA_SUPPORT_) || defined(_CANAL_NL_SUPPORT_) || defined(_DPLUS_SUPPORT_)
	if ((ident & 0xFFF0) == 0x60) return 1;
#endif
#if defined(_CANAL_FR_SUPPORT_)
	if ((ident & 0xFFF0) == 0x80) return 1;
#endif

#if defined(_SKYITALIA_SUPPORT_)
	if ((ident & 0xFFF0) == 0x70) return 1;
#endif
	return 0;
}

//----------------------------------------------------------------------
//----------------------------------------------------------------------
//----------------------------------------------------------------------
//----------------------------------------------------------------------
//----------------------------------------------------------------------
//----------------------------------------------------------------------
//----------------------------------------------------------------------
//----------------------------------------------------------------------
//----------------------------------------------------------------------
//----------------------------------------------------------------------
//----------------------------------------------------------------------
//----------------------------------------------------------------------
//----------------------------------------------------------------------
//----------------------------------------------------------------------
#define _BEFORE_S_ (pos-8)
#define _AFTER_S_  (pos+1)

#ifdef _CANAL_FR_SUPPORT_
static int
xseka_fr_Isprovid(uint16_t ident)
{
	if ((ident & 0xf0) == 0x80)	return 1;
	return 0;
}


static void
xseka_fr_PRE_SSE_Core(uint8_t *buf, uint8_t *data, int i)
{
	uint8_t *T1 = seka2_SSE_3072;
	uint8_t *T2 = seka2_SSE_2048;

	buf[ 0]= data[0x06]^T2[i+0x0a];
	buf[ 1]= data[0x01]^T2[i+0x00];
	buf[ 2]= data[0x02]^T1[i+0x00];
	buf[ 3]= data[0x03]^T2[i+0x04];
	buf[ 4]=~data[0x04];
	buf[ 5]= data[0x05]^T1[i+0x01];
	buf[ 6]= data[0x00]^T2[i+0x0f];
	buf[ 7]= data[0x07]^T1[i+0x02];
	buf[ 8]= data[0x08]^T1[i+0x00];
	buf[ 9]= data[0x0d]^T2[i+0x14];
	buf[10]= data[0x0f]^T2[i+0x07];
	buf[11]=~data[0x0b];
	buf[12]= data[0x0c]^T1[i+0x00];
	buf[13]= data[0x09]^T2[i+0x19];
	buf[14]= data[0x0e]^T2[i+0x1e];
	buf[15]= data[0x0a]^T1[i+0x01];
}

static void
xseka_fr_POST_SSE_Core1(uint8_t *data, int pos)
{
	data[_BEFORE_S_+0]^=-(0x2d);
	data[_BEFORE_S_+1]-=  0x22;
	data[_BEFORE_S_+2]^=  0x1d;
	data[_BEFORE_S_+3]^=-(0x68);
	data[_BEFORE_S_+4] =~data[_BEFORE_S_ + 4];
	data[_BEFORE_S_+5]^=  0x26;
	data[_BEFORE_S_+6]^=  0x09;
	data[_BEFORE_S_+7]-=  0x3e;
	data[_AFTER_S_ +0]^=-(0x5d);
	data[_AFTER_S_ +1]-=  0x74;
	data[_AFTER_S_ +2]^=  0x2d;
	data[_AFTER_S_ +3]^=-(0x2a);
	data[_AFTER_S_ +4]+=  0x0d;
	data[_AFTER_S_ +5]^=-(0x6c);
	data[_AFTER_S_ +6]^=-(0x76);
	data[_AFTER_S_ +7]+=  0x31;
}

static void
xseka_fr_POST_SSE_Core2(uint8_t *buf, uint8_t *data, int pos)
{
	uint8_t *T1 = seka2_80_SSEP_256;

	memcpy(buf, &T1[data[_AFTER_S_+4]+0x48], 56);
}

static void
xseka_fr_POST_SSE_Core3(uint8_t *data, uint8_t *buf, int pos)
{
	data[_BEFORE_S_+4]=buf[5];
	data[_BEFORE_S_+5]=buf[4];
	data[_BEFORE_S_+6]=buf[7];
	data[_BEFORE_S_+7]=buf[2];
	data[_AFTER_S_ +0]=buf[3];
	data[_AFTER_S_ +1]=buf[1];
	data[_AFTER_S_ +2]=buf[0];
	data[_AFTER_S_ +3]=buf[6];
}

static void
xseka_fr_POST_SSE_Core4(uint8_t *data, int pos)
{
	data[_AFTER_S_+0]=data[_BEFORE_S_+3]^  0x3e;
	data[_AFTER_S_+1]=data[_BEFORE_S_+1]^  0x5e;
	data[_AFTER_S_+2]=data[_BEFORE_S_+5]^  0x2f;
	data[_AFTER_S_+3]=data[_BEFORE_S_+0]^  0x77;
	data[_AFTER_S_+4]=data[_BEFORE_S_+6]^-(0x4b);
	data[_AFTER_S_+5]=data[_BEFORE_S_+2]^-(0x38);
	data[_AFTER_S_+6]=data[_BEFORE_S_+7]^  0x29;
	data[_AFTER_S_+7]=data[_BEFORE_S_+4]^  0x2b;
}

static void
xseka_fr_POST_CW(uint8_t *data)
{
	uint8_t 	*T1 = seka2_SSE_3072;
	uint8_t 	*T2 = seka2_SSE_2048;
	uint8_t 	*T3 = seka2_80_SSEP_256;
	uint8_t	*T4 = seka2_80_CW_512;
	int	idx;
	uint8_t 	key[8];

	idx=((data[0]<<8)|data[1]);     key[0]=T3[idx & 0x3FF];
	idx= (idx + key[0]);            key[1]=T3[idx & 0x3FF];
	idx=((data[2]<<8)|data[3]);     key[2]=T4[idx & 0x1FF];
	idx= idx + key[2];              key[3]=T4[idx & 0x1FF];
	idx=((data[8+4]<<8)|data[8+5]); key[4]=T2[idx & 0x7FF];
	idx= idx + key[4];              key[5]=T2[idx & 0x7FF];
	idx=((data[8+6]<<8)|data[8+7]); key[6]=T1[idx & 0xBFF];
	idx= idx + key[6];              key[7]=T1[idx & 0xBFF];

	DES_seka(key, DES_ECS2_CRYPT, data+4);
}

static void
xseka_fr_XOR_Chain(uint8_t *data, uint16_t idx)
{
	static uint8_t tabIdx[] = { 0x00, 0x08, 0x03, 0x1F, 0x06, 0x32, 0x12, 0x0C };
	static uint8_t tabXor[] = { 0x77, 0x2B, 0xC8, 0xEE, 0x2F, 0xD3, 0x22, 0x29 };
	static uint8_t tabPos[] = {    0,    2,    1,    6,    4,    5,    7,    3 };

	int idx1, idx2;
	int i;
	uint8_t 	xorVal=0;
	uint8_t 	*T1 = (uint8_t *)seka2_issuer->masktab;
	uint8_t 	*T2 = seka2_SSE_3072;

	idx1 = (idx ^ 0x17AC) & 0x3FFF;
	idx2 = idx1 & 0xBFF;
	for (i=0; i<8; i++)
	{
		idx1 = (idx1 + tabIdx[i]) & 0x3FFF;
		idx2 = (idx2 + xorVal) & 0xBFF;
		xorVal ^= T1[idx1] ^ tabXor[i];
		data[tabPos[i]] ^= xorVal ^ T2[idx2];
	}
}

static void
xseka_fr_MOD_Signature(uint8_t *mod, uint8_t *pk)
{
	uint8_t 	*T1 = seka2_80_SSEP_256;
	uint32_t	idx;

	idx = ((mod[18] << 8) | mod[19]) & 0x3FF;
	mod[10]  = T1[idx];
	mod[13] ^= pk[6];
	idx = ((mod[15] << 8) | mod[13]) & 0x3FF;
	mod[16]  = T1[idx];

	DES_seka(mod+10, DES_ECS2_CRYPT, mod);
}
#endif	// _CANAL_FR_SUPPORT_
//----------------------------------------------------------------------
//----------------------------------------------------------------------
//----------------------------------------------------------------------
//----------------------------------------------------------------------
#ifdef _CANAL_NL_SUPPORT_
static int
xseka_nl_Isprovid(uint16_t ident)
{
	if (ident == 0x6A) return 1;
	if (ident == 0x6B) return 1;
	if (ident == 0x6C) return 1;
	if (ident == 0x6D) return 1;
	return 0;
}


static void
xseka_nl_PRE_SSE_Core(uint8_t *buf, uint8_t *data, int i)
{
	uint8_t *T1 = seka2_SSE_3072;
	uint8_t *T2 = seka2_SSE_2048;

	buf[0] = data[7] ^T1[i+0x17];
	buf[1] = data[1] ^T2[i+0x07];
	buf[2] = data[2] ^T1[i+0x03];
	buf[3] = data[3] ^T2[i+0x0C];
	buf[4] =~data[4];
	buf[5] = data[5] ^T1[i+0x1E];
	buf[6] = data[6] ^T1[i+0x11];
	buf[7] = data[0] ^T2[i+0x0F];
	buf[8] = data[9] ^T1[i+0x15];
	buf[9] = data[8] ^T2[i+0x04];
	buf[10]= data[12]^T2[i+0x07];
	buf[11]= data[11]^T1[i+0x16];
	buf[12]= data[10]^T1[i+0x01];
	buf[13]= data[13]^T1[i+0x0F];
	buf[14]=~data[14];
	buf[15]= data[15]^T2[i+0x0B];
}

static void
xseka_nl_POST_SSE_Core1(uint8_t *data, int pos)
{
	// modify 8 bytes before signature byte (0x82)
	data[_BEFORE_S_+0] ^= 0xd6; data[_BEFORE_S_+1] ^= 0x96;
	data[_BEFORE_S_+2] -= 0x51; data[_BEFORE_S_+3] ^= 0x3a;
	data[_BEFORE_S_+4] -= 0x8d; data[_BEFORE_S_+5] ^= 0xf1;
	data[_BEFORE_S_+6] -= 0xc2; data[_BEFORE_S_+7] ^= 0xb1;

	data[_AFTER_S_ +0] ^= 0x84; data[_AFTER_S_ +1] ^= 0xf8;
	data[_AFTER_S_ +2] -= 0x7d; data[_AFTER_S_ +3]  = ~(data[_AFTER_S_+3]);
	data[_AFTER_S_ +4] ^= 0xfd; data[_AFTER_S_ +5] ^= 0xd0;
	data[_AFTER_S_ +6] ^= 0x77; data[_AFTER_S_ +7] ^= 0x25;
}

static void
xseka_nl_POST_SSE_Core2(uint8_t *buf, uint8_t *data, int pos)
{
	uint8_t	*T1 = seka2_6A_SSEP_256;
	memcpy(buf,&T1[(data[_AFTER_S_+6]+0x19)&0x7F],56);
}

static void
xseka_nl_POST_SSE_Core3(uint8_t *data, uint8_t *buf, int pos)
{
	data[_BEFORE_S_+4]=buf[7];
	data[_BEFORE_S_+5]=buf[0];
	data[_BEFORE_S_+6]=buf[3];
	data[_BEFORE_S_+7]=buf[5];
	data[_AFTER_S_ +0]=buf[6];
	data[_AFTER_S_ +1]=buf[2];
	data[_AFTER_S_ +2]=buf[1];
	data[_AFTER_S_ +3]=buf[4];
}

static void
xseka_nl_POST_SSE_Core4(uint8_t *data, int pos)
{
	data[_AFTER_S_+0]=data[_BEFORE_S_+1] ^ 0x65; data[_AFTER_S_+1]=data[_BEFORE_S_+0] ^ 0x75;
	data[_AFTER_S_+2]=data[_BEFORE_S_+5] ^ 0x35; data[_AFTER_S_+3]=data[_BEFORE_S_+3] ^ 0xd9;
	data[_AFTER_S_+4]=data[_BEFORE_S_+6] ^ 0xb7; data[_AFTER_S_+5]=data[_BEFORE_S_+7] ^ 0x9a;
	data[_AFTER_S_+6]=data[_BEFORE_S_+4] ^ 0xc7; data[_AFTER_S_+7]=data[_BEFORE_S_+2] ^ 0x1f;
}

static void
xseka_nl_POST_CW(uint8_t *data)
{
	uint8_t 	*T1 = seka2_SSE_3072;
	uint8_t 	*T2 = seka2_SSE_2048;
	uint8_t 	*T3 = seka2_6A_CW_512;
	uint8_t 	*T4 = seka2_6A_SSEP_256;
	uint8_t 	key[8];
	uint32_t off2;

	off2  =data[2]^data[8+6];
	key[2]=T4[off2];
	key[5]=T4[(off2+key[2])&0xff];

	off2  =(data[3]<<8)|data[8+4];
	key[0]=T3[off2&0x1ff];
	off2  +=key[2];
	key[4]=T3[off2&0x1ff];

	off2  =(data[0]<<8)|data[8+7];
	key[7]=T2[off2&0x7ff];
	off2 +=key[0];
	key[1]=T2[off2&0x7ff];

	off2  =(data[1]<<8)|data[8+5];
	key[3]=T1[off2&0xbff];
	off2 +=key[4];
	key[6]=T1[off2&0xbff];

	DES_seka(key, DES_ECS2_CRYPT, data+4);
}


static void
xseka_nl_XOR_Chain(uint8_t *data, uint16_t idx)
{
	static uint16_t tabIdx [] = { 0x000, 0x4C3, 0x5D8, 0x63A, 0x471, 0x639, 0x417, 0x6CD };
	static uint8_t  tabXor [] = {  0x84,  0xD6,  0x3A,  0x1F,  0x25,  0xB1,  0x7D,  0xF7 };
	static uint8_t  tabPos1[] = {     2,     4,     3,     4,     5,     7,     6,     7 };
	static uint8_t  tabPos2[] = {     3,     1,     5,     6,     0,     1,     0,     2 };

	uint8_t 	*T1 = seka2_issuer->masktab;
	uint8_t 	*T2 = seka2_SSE_3072;
	uint8_t 	xorval = 0;
	int idx1, idx2;
	int i;

	idx1 = (idx ^ 0x2B36) & 0x3FFF;
	idx2 = idx1 & 0x0BFF;
	for (i=0; i<8; i++)
	{
		idx1=(idx1 + tabIdx[i]) & 0x3FFF;
		idx2=(idx2 + xorval) & 0xBFF;
		xorval ^= T1[idx1] ^ tabXor[i];
		data[tabPos1[i]] ^= xorval;
		data[tabPos2[i]] ^= T2[idx2];
	}
}
#endif	// _CANAL_NL_SUPPORT_
//----------------------------------------------------------------------
//----------------------------------------------------------------------
//----------------------------------------------------------------------
//----------------------------------------------------------------------
#if 0
void
xseka_be_PRE_SSE_Core(uint8_t *buffer, uint8_t *data, int i, bool emm)
{
	uint8_t *T1 = seka2_SSE_3072;
	uint8_t *T2 = seka2_SSE_2048;

	uint8_t 	XorVal;
	if (emm)
		XorVal=0xB1;        // i's the same as 7.6 !
	else
		XorVal=0x9C;

	buffer[0] = data[0] ^T1[i+0x0B];
	buffer[1] = data[6] ^T2[i+0x07];
	buffer[2] = data[2] ^T2[i+0x06] ^ XorVal;
	buffer[3] = data[3] ^T1[i+0x0D];
	buffer[4] = data[4] ^T1[i+0x15];
	buffer[5] =~data[5];
	buffer[6] = data[1] ^T1[i+0x13];
	buffer[7] = data[14]^T2[i+0x0C] ^ XorVal;
	buffer[8] = data[11]^T1[i+0x03];
	buffer[9] = data[9] ^T1[i+0x09];
	buffer[10]= data[10]^T2[i+0x0F];
	buffer[11]= data[8] ^T1[i+0x0B];
	buffer[12]= data[12]^T1[i+0x1B];
	buffer[13]=~data[13];
	buffer[14]= data[7] ^T1[i+0x10];
	buffer[15]= data[15]^T2[i+0x04];

}
void
xseka_be_POST_SSE_Core1(uint8_t *data, int pos)
{
	// modify 8 bytes before signature byte (0x82)
	data[_BEFORE_S_+0] ^= 0xF4; data[_BEFORE_S_+1] ^= 0x6D;
	data[_BEFORE_S_+2] -= 0xF5; data[_BEFORE_S_+3]  =~data[_BEFORE_S_ + 3];
	data[_BEFORE_S_+4] ^= 0xA3; data[_BEFORE_S_+5] -= 0xC8;
	data[_BEFORE_S_+6] ^= 0x83; data[_BEFORE_S_+7] ^= 0xD6;

	data[_AFTER_S_ +0] -= 0xF1; data[_AFTER_S_ +1] ^= 0x62;
	data[_AFTER_S_ +2] ^= 0xE0; data[_AFTER_S_ +3] -= 0x71;
	data[_AFTER_S_ +4] ^= 0xBA; data[_AFTER_S_ +5] -= 0xd9;
	data[_AFTER_S_ +6] ^= 0xDE; data[_AFTER_S_ +7] ^= 0x29;
}

void
xseka_be_POST_SSE_Core2(uint8_t *buf, uint8_t *data, int pos, bool emm)
{
	uint8_t	*T1 = xseka_be_SSEP_256;
	memcpy(buf,&T1[((data[_AFTER_S_+5]^0xB8)+0x0A)&0x7F],56);

	if (emm)
		buf[0x02]^=0xC4;
	else
		buf[0x02]^=0x41;
}
void
xseka_be_POST_SSE_Core3(uint8_t *data, const uint8_t *buf, int pos)
{
	data[_BEFORE_S_+4]=buf[3];
	data[_BEFORE_S_+5]=buf[1];
	data[_BEFORE_S_+6]=buf[4];
	data[_BEFORE_S_+7]=buf[5];
	data[_AFTER_S_ +0]=buf[7];
	data[_AFTER_S_ +1]=buf[0];
	data[_AFTER_S_ +2]=buf[6];
	data[_AFTER_S_ +3]=buf[2];
}

void
xseka_be_POST_SSE_Core4(uint8_t *data, int pos)
{
	data[_AFTER_S_+0]=data[_BEFORE_S_+4] ^ 0x47; data[_AFTER_S_+1]=data[_BEFORE_S_+2] ^ 0x95;
	data[_AFTER_S_+2]=data[_BEFORE_S_+5] ^ 0x1C; data[_AFTER_S_+3]=data[_BEFORE_S_+7] ^ 0xC3;
	data[_AFTER_S_+4]=data[_BEFORE_S_+1] ^ 0x95; data[_AFTER_S_+5]=data[_BEFORE_S_+0] ^ 0x58;
	data[_AFTER_S_+6]=data[_BEFORE_S_+6] ^ 0xA4; data[_AFTER_S_+7]=data[_BEFORE_S_+3] ^ 0x17;
}
#endif
//----------------------------------------------------------------------
//----------------------------------------------------------------------
//----------------------------------------------------------------------
//----------------------------------------------------------------------
#ifdef _CYFRA_SUPPORT_
static int
xseka_pl_Isprovid(uint16_t ident)
{
	if (ident == 0x65) return 1;
	return 0;
}

static void
xseka_pl_PRE_CW(uint8_t *data)
{
	uint8_t *XT = (uint8_t *)seka2_issuer->xt;
	uint8_t *PT = (uint8_t *)seka2_issuer->pt;
	uint8_t temp[16];
	int i;

	xseka_xxor(temp, 16, data, XT);
	for (i=15; i>=0; i--) data[i] = temp[PT[i]];
}

static void
xseka_pl_XOR_Chain(uint8_t *data, uint16_t idx)
{
	int i;
	uint8_t *MT = (uint8_t *)seka2_issuer->masktab;

	for(i=0; i<8; i++) data[i] ^= MT[idx++];
}
#endif	// _CYFRA_SUPPORT_
//======================================================================
//======================================================================
//======================================================================
//======================================================================
//======================================================================
//======================================================================
static void
xseka_pre_sse_core(uint8_t *data, int pos)
{
	#ifdef _CYFRA_SUPPORT_
		if (xseka_pl_Isprovid(seka_prid))
		{

	 	}
	#endif	// _CYFRA_SUPPORT_

	#ifdef _CANAL_NL_SUPPORT_
		if (xseka_nl_Isprovid(seka_prid))
		{
			uint8_t 	tempbuf[80];
			uint8_t 	*T1;
			int i, j;

			T1 = seka2_6A_SSEP_80;

			data += pos + 5; // Start at offset 5
			for (i=4; i>=0; i--)
			{
				j=i*16;
				xseka_nl_PRE_SSE_Core(&tempbuf[j], &data[j], i);
			}
			for(i=79; i>=0; i--) data[i] = tempbuf[i]^T1[i];
		}
	#endif	// _CANAL_NL_SUPPORT_

	#ifdef _CANAL_FR_SUPPORT_
		if (xseka_fr_Isprovid(seka_prid))
		{
	 		uint8_t 	tempbuf[80];
			uint8_t 	*T1;
			int i, j;

			T1 = seka2_80_SSEP_80;

			data += pos + 5; // Start at offset 5
			for (i=4; i>=0; i--)
			{
				j=i*16;
				xseka_fr_PRE_SSE_Core(&tempbuf[j], &data[j], i);
			}
			for(i=79; i>=0; i--) data[i] = tempbuf[i] ^ T1[i];
	 	}
	#endif	// _CANAL_FR_SUPPORT_
}

static void
xseka_post_sse_core(uint8_t *data, int pos)
{
	#ifdef _CYFRA_SUPPORT_
		if (xseka_pl_Isprovid(seka_prid))
		{

	 	}
	#endif	// _CYFRA_SUPPORT_

	#ifdef _CANAL_NL_SUPPORT_
		if (xseka_nl_Isprovid(seka_prid))
		{
			uint8_t 	digest [20];
			uint8_t 	tempbuf[64];

			xseka_nl_POST_SSE_Core1(data, pos);
			// create the SHA hash buffer
			memcpy(tempbuf+0,&data[_BEFORE_S_+0],4);
			memcpy(tempbuf+4,&data[_AFTER_S_ +4],4);
			xseka_nl_POST_SSE_Core2(tempbuf+8,data,pos);
			// Calc Signature of the generated buffer here
			SHA1_sekaSignature(tempbuf, sizeof(tempbuf), digest, FALSE, 0x00, 0x00);

			// Prepare DES data
			memcpy(tempbuf+0,&data[_BEFORE_S_+4],4);
			memcpy(tempbuf+4,&data[_AFTER_S_ +0],4);

			// DES Enrypt
			DES_seka(digest, DES_ECS2_CRYPT, tempbuf);
			// modify data with encrypted DES data
			xseka_nl_POST_SSE_Core3(data,tempbuf,pos);
			// save the signature
			memcpy(tempbuf,data+_AFTER_S_,8);
			xseka_nl_POST_SSE_Core4(data,pos);
			// put the signature in the data
			memcpy(data+_BEFORE_S_,tempbuf,8);
		}
	#endif	// _CANAL_NL_SUPPORT_

	#ifdef _CANAL_FR_SUPPORT_
		if (xseka_fr_Isprovid(seka_prid))
		{
			uint8_t 	digest [20];
			uint8_t 	tempbuf[64];

			xseka_fr_POST_SSE_Core1(data,pos);
			// create the SHA hash buffer
			memcpy(tempbuf+0,&data[_BEFORE_S_+0],4);
			memcpy(tempbuf+4,&data[_AFTER_S_ +4],4);
			xseka_fr_POST_SSE_Core2(tempbuf+8,data,pos);
			// Calc Signature of the generated buffer here
			SHA1_sekaSignature(tempbuf, sizeof(tempbuf), digest, FALSE, 0x00, 0x00);

			// Prepare DES data
			memcpy(tempbuf+0,&data[_BEFORE_S_+4],4);
			memcpy(tempbuf+4,&data[_AFTER_S_ +0],4);

			// DES Enrypt
			DES_seka(digest, DES_ECS2_CRYPT, tempbuf);
			// modify data with encrypted DES data
			xseka_fr_POST_SSE_Core3(data,tempbuf,pos);
			// save the signature
			memcpy(tempbuf,data+_AFTER_S_,8);
			xseka_fr_POST_SSE_Core4(data,pos);
			// put the signature in the data
			memcpy(data+_BEFORE_S_,tempbuf,8);
	 	}
	#endif	// _CANAL_FR_SUPPORT_
}

static void
xseka_mod_signature(uint8_t *mod, uint8_t *pk)
{
	#ifdef _CANAL_FR_SUPPORT_
		if (xseka_fr_Isprovid(seka_prid))
		{
			xseka_fr_MOD_Signature(mod, pk);
	 	}
	#endif	// _CANAL_FR_SUPPORT_
}


static void
xseka_pre_cw(uint8_t *data)
{
	#ifdef _CYFRA_SUPPORT_
		if (xseka_pl_Isprovid(seka_prid))
		{
			xseka_pl_PRE_CW(data);
	 	}
	#endif	// _CYFRA_SUPPORT_
}

static void
xseka_post_cw(uint8_t *data)
{
	#ifdef _CANAL_NL_SUPPORT_
		if (xseka_nl_Isprovid(seka_prid))
		{
			xseka_nl_POST_CW(data);
		}
	#endif	// _CANAL_NL_SUPPORT_

	#ifdef _CANAL_FR_SUPPORT_
		if (xseka_fr_Isprovid(seka_prid))
		{
			xseka_fr_POST_CW(data);
	 	}
	#endif	// _CANAL_FR_SUPPORT_
}
//======================================================================
//======================================================================
//======================================================================
//======================================================================
//======================================================================
//======================================================================
//======================================================================
//======================================================================
static uint16_t
xseka_mtab_GetIndex(uint8_t *data, int len)
{
	unsigned int sum = 0;
	int i;

	for (i=1; i<len; i+=2)
	{
		sum += ((data[i-1]<<8) + data[i]);
	}
	if (len&1) sum += (data[len-1]<<4);
	return (sum & 0x3FFF);
}


static void
xseka_mtab_XOR_Chain(uint8_t *data, uint16_t idx)
{
	#ifdef _CANAL_NL_SUPPORT_
		if (xseka_nl_Isprovid(seka_prid))
		{
			xseka_nl_XOR_Chain(data, idx);
	 	}
	#endif	// _CANAL_NL_SUPPORT_

	#ifdef _CANAL_FR_SUPPORT_
		if (xseka_fr_Isprovid(seka_prid))
		{
			xseka_fr_XOR_Chain(data, idx);
	 	}
	#endif	// _CANAL_FR_SUPPORT_

	#ifdef _CYFRA_SUPPORT_
		if (xseka_pl_Isprovid(seka_prid))
		{
			xseka_pl_XOR_Chain(data, idx);
	 	}
	#endif	// _CYFRA_SUPPORT_
}


int
xseka_sse_Decrypt(uint8_t *source, uint8_t *key, int n, int start, uint8_t *T1, uint8_t *T2)
{
	uint8_t 	ucLastBlock[8];
	uint16_t	mtidx;
	int sigStart = n-source[n-1]-9; // 82 <8 bytes> P5(sigStart)
	int encrLen	 = sigStart-16;
	int i;
	int rest_bytes;

	MYEMU_TRACE("xseka:encrLen = %x sigStart = %x\n", encrLen, sigStart);
	if (encrLen >= n || encrLen < 0)
	{
		MYEMU_TRACE("xseka:encrLen(%d,%d) error in SE\n", encrLen, sigStart);
		return 0;
	}
	if (sigStart < 16)
	{
		MYEMU_TRACE("xseka:sigStart(%d) error in SE\n", sigStart);
		return 0;
	}

//	myprdump("Before xseka_sse_Decrypt", source, n);

	xseka_Decrypt(source+sigStart-8, key, T1,T2);
	mtidx = xseka_mtab_GetIndex(source+start, sigStart-8-start);
	xseka_mtab_XOR_Chain(source+sigStart-8, mtidx);

	for (i=start; i<encrLen; i+=8)
	{
		xseka_Decrypt(source+i,key,T1,T2);
		mtidx = xseka_mtab_GetIndex(source+i+8, 8);
		xseka_mtab_XOR_Chain(source+i, mtidx);
	}

	rest_bytes = sigStart & 0x07;
	if (!rest_bytes) rest_bytes = 8;

	// Last Block
	memset(ucLastBlock, 0, 8);
	memcpy(ucLastBlock, source+sigStart-rest_bytes, rest_bytes);
	xseka_Decrypt(ucLastBlock,key,T1,T2);

	xseka_Decrypt(source+i,key,T1,T2);

	mtidx = xseka_mtab_GetIndex(ucLastBlock, 8);
	xseka_mtab_XOR_Chain(source+i, mtidx);

//	myprdump("After  xseka_sse_Decrypt", source, n);
	return 1;
}
//----------------------------------------------------------------------
//----------------------------------------------------------------------
//----------------------------------------------------------------------
//----------------------------------------------------------------------
//----------------------------------------------------------------------
//----------------------------------------------------------------------
static int
xseka_nano0f_Process(int count, uint8_t *_Hashdw, uint8_t *pk, uint8_t *T1, uint8_t *T2)
{
	uint8_t 	*MT;
	uint8_t 	buffA[8];
	uint8_t 	buffB[16];
	uint8_t 	buffC[16];
	uint8_t 	buffD[16];
	int	i;
	int off;

	if (count == 0) return 1;

	MT = (uint8_t *)seka2_issuer->masktab;
	while (count--)
	{
		xseka_swap8_4(_Hashdw);
		memcpy(buffA,_Hashdw,8);
		xseka_Decrypt(buffA,pk,seka2_issuer->t19x,seka2_issuer->t29x);

		off = _seka_w16_(buffA,0,0x3FFF);
		xseka_xxor(buffB, 8, &MT[off],&MT[0x3FFF-off]);
		xseka_xxor(buffB, 8, buffB,&MT[(((buffA[6] ^ buffB[0])<<8) + (buffA[7] ^ buffB[ 7]))&0x3FFF]);

		off = _seka_w16_(buffA,2,0x3FFF);
		xseka_xxor(buffC,16, &MT[off],&MT[0x3FFF-off]);
		xseka_xxor(buffC,16, buffC,&MT[(((buffA[6] ^ buffC[0])<<8) + (buffA[7] ^ buffC[15]))&0x3FFF]);

		off = _seka_w16_(buffA,4,0x3FFF);
		for (i=0; i<16; i++) off = _seka_w16_(MT,off,0x3FFF);

		memcpy(buffD,buffB,8);
		xseka_Decrypt(buffB,buffC,&MT[off],&MT[off+256]);

		xseka_xxor(buffB,8,buffB,buffD);

		xseka_Decrypt(buffB,pk,T1,T2);

		xseka_xxor(_Hashdw,8,_Hashdw,buffB);
	}

	for (i=0; i<8; i++)
	{
		pk[i]   = buffB[i];
		pk[i+8] = ~(_seka_sn8_(buffB[i]));
	}
	return 1;
}
//----------------------------------------------------------------------
//----------------------------------------------------------------------
//----------------------------------------------------------------------
//----------------------------------------------------------------------
//----------------------------------------------------------------------
//----------------------------------------------------------------------
//----------------------------------------------------------------------
static void
xseka_nano51_AdditionalAlgo(uint8_t *data, uint8_t *key, int mode)
{
	static uint32_t adders[] =
	{
		0x0000,0xe555,0xafff,0x5ffe,0xf552,0x6ffb,0xcff9,0x154c,
		0x3ff4,0x4ff1,0x4543,0x1fea,0xdfe6,0x8537,0x0fdd,0x7fd8
	};
	uint16_t *k  = (uint16_t *)key;
	uint16_t *dd = (uint16_t *)data;
	uint32_t	d1=dd[0], d2=dd[1], d3=dd[2], d4=dd[3];
	int i;

	if (!mode)
	{
		for(i=0; i<0x10; i++)
		{
			uint32_t adder = adders[i];

			d1 += (k[0] + d3 + adder) ^ (k[1] + d4 + adder);
			d2 += (k[2] + d3 + adder) ^ (k[3] + d4 + adder);
			d1 = _seka_rr16_(d1,5);
			d2 = _seka_rl16_(d2,3);
			d3 += (k[0] + d1 + adder) ^ (k[1] + d2 + adder);
			d4 += (k[2] + d1 + adder) ^ (k[3] + d2 + adder);
			d3 = _seka_rl16_(d3,3);
			d4 = _seka_rr16_(d4,5);
		}
	}
	else
	{
		for (i=0xf; i>=0; i--)
		{
			uint32_t adder = adders[i];

			d4 = _seka_rl16_(d4,5);
			d3 = _seka_rr16_(d3,3);
			d4 -= (k[2] + d1 + adder) ^ (k[3] + d2 + adder);
			d3 -= (k[0] + d1 + adder) ^ (k[1] + d2 + adder);
			d2 = _seka_rr16_(d2,3);
			d1 = _seka_rl16_(d1,5);
			d2 -= (k[2] + d3 + adder) ^ (k[3] + d4 + adder);
			d1 -= (k[0] + d3 + adder) ^ (k[1] + d4 + adder);
		}
	}
	dd[0]=d1; dd[1]=d2; dd[2]=d3; dd[3]=d4;
}

static void
xseka_nano51_Crypto(uint8_t *data, uint8_t *key, uint8_t crypto, uint8_t mode)
{
	switch (crypto)
	{
		case 0: // Xor
			xseka_xxor(data+0,8,key,data+0); xseka_xxor(data+8,8,key,data+8);
			break;

		case 1: // Seca crypto, with 9x table, always!
		{
			uint8_t pk[16];
			uint8_t *T1 = seka2_issuer->t19x;
			uint8_t *T2 = seka2_issuer->t29x;
			memcpy(pk+0,key,8); memcpy(pk+8,key,8);

			if (mode) { xseka_Decrypt(data,pk,T1,T2); xseka_Decrypt(data+8,pk,T1,T2); }
			else     { xseka_Encrypt(data,pk,T1,T2); xseka_Encrypt(data+8,pk,T1,T2); }
			break;
		}

		case 2: // DES crypto (Modified PC1,PC2)
			// DES
			DES_seka(key, (mode) ? DES_ECS2_DECRYPT : DES_ECS2_CRYPT, data);
			DES_seka(key, (mode) ? DES_ECS2_DECRYPT : DES_ECS2_CRYPT, data+8);
			break;

		case 3: // Additional Algo
			xseka_nano51_AdditionalAlgo(data,key,mode);
			xseka_nano51_AdditionalAlgo(data+8,key,mode);
			break;
	}
}


static void
xseka_nano51_Permute(uint8_t *data, uint8_t *pdata, uint8_t *P)
{
	int i;

	if (!P) return;
	for (i=7; i>=0; i--) data[i] = (P[i]) ? pdata[P[i]] : 0x0;
}



#define MAX_PERM51S	12
typedef struct
{
  	uint8_t 	P1[8], P2[8], P3[8], P4[8];
} SEKAII_PERM51;
static SEKAII_PERM51	seka2_perm51[MAX_PERM51S] = {
	{{0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0},},	// 0
	{{2,4,4,3,2,2,4,4},{3,2,4,3,4,4,2,3},{0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0},},	// 1
	{{4,4,3,2,2,3,3,4},{4,2,3,4,3,2,4,2},{0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0},},	// 2
	{{0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0},},	// 3
	{{0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0},},	// 4
	{{0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0},},	// 5
	{{0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0},},	// 6
	{{0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0},},	// 7
	{{0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0},},	// 8
	{{4,4,3,2,3,4,3,2},{2,4,3,2,2,4,4,3},{2,3,4,1,0,0,0,0},{0,0,0,0,0,0,0,0},},	// 9
	{{0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0},},	// A
};


typedef struct
{
	uint8_t	pl[8];
	uint8_t	nl[8];
} SEKAII_XOR512;
typedef struct
{
	uint8_t 	pl5101[16];
	uint8_t 	pl5102[16];
	uint8_t 	pl5104[16];
	uint8_t 	pl5105[16];
	uint8_t 	pl5108[16];
	uint8_t 	pl5109[16];
} SEKAII_XOR51;

static SEKAII_XOR512 seka2_xor512s =
{
//	{0, 3, 0, 5, 0, 0, 4, 3}, 	// 0065
//	{4, 0, 0, 0, 3, 5, 4, 0}, 	// 0065
//	{5, 0, 0, 4, 3, 0, 0, 5},  // 006A
	{3, 0, 0, 0, 2, 4, 3, 0}, 	// 0065
	{4, 0, 0, 3, 2, 0, 0, 4},	// 006A
};
static SEKAII_XOR51	seka2_xor51s  =
{
	{3, 5, 5, 4, 3, 3, 5, 5,	4, 3, 5, 4, 5, 5, 3, 4}, 	// 5101
	{5, 5, 4, 3, 3, 4, 4, 5,	5, 3, 4, 5, 4, 3, 5, 3}, 	// 5102
	{0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0}, 	// 5104
	{0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0}, 	// 5105
	{0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0},	// 5108
	{5, 5, 4, 3, 4, 5, 4, 3,	3, 5, 4, 3, 3, 5, 5, 4},	// 5109
};

static uint8_t			seka2_step51[3] 	= { 3,4,5 };    	// 0065
static uint8_t 		seka2_n51Exp[2]   = {0x11,0x00,};
static uint8_t 		seka2_n51Mod[130] =
{
	0x7D, 0xD9, 0x1E, 0xB8, 0x30, 0x20, 0x73, 0x5D, 0x96, 0x1C, 0x36, 0xBD, 0x9F, 0xAA, 0xEC, 0x5C,
	0x4B, 0x59, 0xD7, 0x23, 0xFF, 0x65, 0x8C, 0x86, 0xBB, 0x8A, 0x72, 0x88, 0x7E, 0x57, 0xF6, 0x7A,
	0x52, 0xF8, 0xD3, 0x0B, 0x0A, 0xC6, 0x6D, 0x8B, 0x03, 0xE4, 0xCD, 0x91, 0xB6, 0xA8, 0x66, 0x94,
	0x95, 0x64, 0x99, 0x60, 0xDA, 0xE1, 0x5C, 0x09, 0x80, 0xAD, 0xD9, 0x16, 0x4E, 0x0C, 0xA8, 0x80,
	0xD8, 0x68, 0x12, 0x92, 0x1D, 0x15, 0xF8, 0xE5, 0x31, 0x8A, 0x81, 0x0D, 0x36, 0x3A, 0x1F, 0xF9,
	0xA1, 0xFA, 0xAF, 0x6D, 0x54, 0x1A, 0xAF, 0x96, 0x4C, 0xB4, 0xCC, 0xF2, 0x86, 0x58, 0x18, 0xBC,
	0x69, 0xF4, 0x54, 0x50, 0x77, 0xFB, 0x9D, 0x78, 0x86, 0xD9, 0xF0, 0x4F, 0xFF, 0x9F, 0x0A, 0xC8,
	0x96, 0x9B, 0xC3, 0xF1, 0x3F, 0x1C, 0x97, 0x38, 0x5A, 0x26, 0x1E, 0x59, 0x63, 0x6E, 0x24, 0x05,
	0x01, 0x00,
};


static int
xseka_nano51_Process(struct s_reader *reader, uint8_t *_Dcw_p, uint8_t *_51src_p, uint8_t *_Hashdw, uint8_t *T1, uint8_t *T2)
{
	SEKAII_PERM51 *_51PT;
	uint8_t 	_51Algo;
	uint8_t 	buffF[8], buffG[16];
	uint8_t 	buf80mask[6]={0,24,44,68,88,108};
	uint8_t 	*xorptr_2 = 0;
	uint8_t 	*xorptr = 0;
	uint8_t 	xorbuf[24], xorBuf51[3];
	uint8_t 	buf40[0x40], buf80[0x82], buf4[4], bufTMP[9], tmpHash[16];
	uint8_t	tmpBuff[8], buffG1[8];
	uint8_t	data5105[20], temp_sign[64], temp_swap;
	uint16_t	*sdata5105;
	int value,nextvalue;
	int Hashlen = 20;	// define Hash length
	int i,j,k;

	if (!_51src_p) return 0;

	_51Algo = (_51src_p[0] & 0x3F);
	MYEMU_TRACE("xseka:51Algo = %02X {%04X}\n", _51Algo, seka_prid);

	_51PT   = &seka2_perm51[_51Algo];
	if (!_51PT)
	{
		MYEMU_TRACE("xseka:51Algo failed to get permutation table\n");
		return 0;
	}
	//
	//
	// 5105.5109
	//
	//
	//
	switch (_51Algo)
	{
		case 0x01:
		case 0x02:
		case 0x05:
		case 0x09:
			memset(xorbuf, 0, sizeof(xorbuf));
			switch (_51Algo)
			{
				case 0x01: 	xorptr = seka2_xor51s.pl5101; break;
				case 0x02: 	xorptr = seka2_xor51s.pl5102; break;
				case 0x04: 	xorptr = seka2_xor51s.pl5104; break;
				case 0x05: 	xorptr = seka2_xor51s.pl5105; break;
				case 0x08: 	xorptr = seka2_xor51s.pl5108; break;
				case 0x09: 	xorptr = seka2_xor51s.pl5109; break;
			}
			switch (seka_prid)
			{
				case 0x80:
				case 0x81:
				case 0x82:
				case 0x84:
				case 0x86:
				case 0x65: 	xorptr_2 = seka2_xor512s.pl; break;
				case 0x6A:
				case 0x6B:
				case 0x6C:
				case 0x6D:	xorptr_2 = seka2_xor512s.nl; break;
				default:		xorptr_2 = 0;
			}
			if (!xorptr || !xorptr_2)
			{
				MYEMU_TRACE("xseka:51Algo failed to get xor51 table\n");
				return 0;
			}
			for (i=0; i<16; i++) if (xorptr[i]) xorbuf[i] = _51src_p[(xorptr[i]-1)];
			for (i=16;i<24; i++) if (xorptr_2[i-16]) xorbuf[i] = _51src_p[(xorptr_2[i-16])];

			// special permutation seca2 V7.3
			switch (seka_prid)
			{
				case 0x6A:
				case 0x6B:
				case 0x6C:
				case 0x6D:
					tmpHash[ 0] = _Hashdw[ 4];	tmpHash[ 1] = _Hashdw[11];
					tmpHash[ 2] = _Hashdw[ 0];	tmpHash[ 3] = _Hashdw[12];
					tmpHash[ 4] = _Hashdw[ 3];	tmpHash[ 5] = _Hashdw[10];
					tmpHash[ 6] = _Hashdw[ 2];	tmpHash[ 7] = _Hashdw[15];
					tmpHash[ 8] = _Hashdw[ 9];	tmpHash[ 9] = _Hashdw[ 5];
					tmpHash[10] = _Hashdw[13];	tmpHash[11] = _Hashdw[ 6];
					tmpHash[12] = _Hashdw[ 1];	tmpHash[13] = _Hashdw[14];
					tmpHash[14] = _Hashdw[ 7];	tmpHash[15] = _Hashdw[ 8];
					break;
				default:
					memcpy(tmpHash, _Hashdw, 8);	// copy first 8 bytes HASH to tmpHash
					break;
			}
			break;

		default:
			MYEMU_TRACE("xseka:51Algo(%02X) data incorrect or proccessing not needed\n", _51Algo);
			return 0;
	}
	//
	//
	//
	switch (_51Algo)
	{
		case 0x01:
		case 0x02:
			{
				int addAlgoMode;

				// Permutation 1
				xseka_nano51_Permute(buffF,_51src_p,_51PT->P1);

				xseka_xxor(buffG,8,buffF,_Hashdw);

				addAlgoMode=(_51src_p[0]&1)^1;
				for (i=(_51src_p[1]&0x0f); i>0; i--) xseka_nano51_AdditionalAlgo(buffG,_Hashdw+8,addAlgoMode);
				// Permutation 2
				xseka_nano51_Permute(buffF,_51src_p,_51PT->P2);
				xseka_xxor(buffG,8,buffF,buffG);

				// Permutation 3
				xseka_nano51_Permute(buffF,_51src_p,_51PT->P3);
				xseka_xxor(buffG,8,buffF,buffG);
				// Permutation 4
				xseka_nano51_Permute(buffF,_51src_p,_51PT->P4);
				xseka_xxor(buffG,8,buffF,buffG);
				break;
			}

		case 0x05:	// nano 51 05 algo
				//buff11 = tmpHash
				switch (seka_prid)
				{
					case 0x65:
						tmpBuff[0] = _51src_p[2] ^ tmpHash[0];
						tmpBuff[1] =  tmpBuff[0] ^ tmpHash[1];
						tmpBuff[2] = _51src_p[4] ^ tmpHash[2];
						tmpBuff[3] =  tmpBuff[2] ^ tmpHash[3];
						tmpBuff[4] = _51src_p[3] ^ tmpHash[4];
						tmpBuff[5] =  tmpBuff[4] ^ tmpHash[5];
						tmpBuff[6] =  tmpBuff[3] ^ tmpHash[6];
						tmpBuff[7] =  tmpBuff[5]  ^tmpHash[7];
						break;
					case 0x6A:
					case 0x6B:
					case 0x6C:
					case 0x6D:
						tmpBuff[4] = _51src_p[2] ^ tmpHash[6];
						tmpBuff[3] = _seka_sn8_((tmpBuff[4] ^ tmpHash[0]));
						tmpBuff[2] = _51src_p[4] ^ tmpHash[5];
						tmpBuff[0] =  tmpBuff[3] ^ tmpHash[1];
						tmpBuff[5] = _seka_sn8_(_51src_p[3]) ^ tmpHash[7];
						tmpBuff[6] =  tmpBuff[5] ^ tmpHash[2];
						tmpBuff[7] =  tmpBuff[2] ^ tmpHash[4];
						tmpBuff[1] =  tmpBuff[0] ^ tmpHash[3];
						break;
					default:
						MYEMU_TRACE("xseka:51Algo(%02X) data incorrect\n", _51Algo);
						return 0;
				}

				for (i=0; i<4; i++)
				{
					temp_swap = tmpBuff[7-i];
					tmpBuff[7-i]=tmpBuff[i];
					tmpBuff[i]=temp_swap;
				}
				for (i=0; i<64; i+=8) memcpy(&temp_sign[i], tmpBuff, 8);

				// Calc Signature of the generated buffer here
				SHA1_sekaSignature(temp_sign, 0x40, data5105, FALSE, 0x00, 0x00);

				for (i=0; i<10; i++)
				{
					temp_swap 		= data5105[19-i];
					data5105[19-i] = data5105[i];
					data5105[i] 	= temp_swap;
				}
				sdata5105 = (unsigned short *)data5105;
				sdata5105[1] = ~sdata5105[0];
				for (i=0; i<15; i++)
				{
					sdata5105[9] += sdata5105[0];
					sdata5105[8] += sdata5105[1];
					sdata5105[7] += (sdata5105[8] + sdata5105[4]) ^ (sdata5105[9] + sdata5105[5]);
					sdata5105[6] += ((~sdata5105[8]) + sdata5105[5]) ^ ((~sdata5105[9]) + sdata5105[4]);
					sdata5105[5] -= (sdata5105[8]+sdata5105[6]) ^ (sdata5105[9]+sdata5105[7]);
					sdata5105[4] -= ((~sdata5105[8])+sdata5105[7]) ^ ((~sdata5105[9])+sdata5105[6]);
				}
				sdata5105[0]=sdata5105[7];
				sdata5105[1]=sdata5105[6];
				sdata5105[2]=sdata5105[5];
				sdata5105[3]=sdata5105[4];
				memcpy(tmpHash, data5105, 8);

				switch (seka_prid)
				{
					case 0x65:
						buffG[0]=_51src_p[2]^tmpHash[0];
						buffG[1]=_51src_p[4]^tmpHash[1];
						buffG[2]=_51src_p[3]^tmpHash[2];
						buffG[3]=buffG[0]^tmpHash[3];
						buffG[4]=buffG[3]^tmpHash[4];
						buffG[5]=buffG[2]^tmpHash[5];
						buffG[6]=buffG[1]^tmpHash[6];
						buffG[7]=buffG[5]^tmpHash[7];
						break;
					case 0x6A:
					case 0x6B:
					case 0x6C:
					case 0x6D:
						buffG[6]=_51src_p[3]^tmpHash[7];
						buffG[3]=_seka_sn8_((_51src_p[4]^tmpHash[3]));
						buffG[2]=_51src_p[2]^tmpHash[2];
						buffG[1]=0-(buffG[3]^tmpHash[4]);
						buffG[7]=buffG[6]^tmpHash[1];
						buffG[0]=buffG[2]^tmpHash[5];
						buffG[5]=buffG[1]^tmpHash[0];
						buffG[4]=buffG[7]^tmpHash[6];
						break;
				}
				break;

		case 0x09:	// nano 51 09 algo
			#if 0
				{
					uint8_t 	buff1[128], buff2[64], buff3[9];
					uint32_t sum = 0;

					// prepare buffers for rsa data
					for (i=0; i<20; i++)
						buff1[i]=buff2[i]=buff2[i+20]=buff2[i+40]=_Hashdw[i];
					memcpy(buff3,_51src_p+2,3);
					for (i=0; i< 8; i++)
						buff1[i] = buff3[_51PT->P1[i]-2] ^= buff1[i];

					for (i=0; i<20; i++)
						buff1[i+24]=buff1[i+44]=buff1[i+68]=buff1[i+88]=buff1[i+108]=buff1[i];

					for (i=0; i< 4; i++)
					{
						uint8_t t=_51src_p[_51PT->P3[i]];

						if (_51PT->P3[i]==1) t&=0x0F;
						buff1[i+20]=buff1[i+64]=buff2[i+60]=t;
					}

					memcpy(buff3,buff1,9);
					for (j=0; j<64; j++)
					{ // XOR even with buff2, odd with 0xFF
						buff1[ j*2   ] ^= buff2[j];
						buff1[(j*2)+1] ^= 0xFF;
					}

					// RSA decrypt
					BN_bin2bn(seka2_n51Mod, 128, &er_n51Mod);
					BN_bin2bn(seka2_n51Exp, 1, &er_n51Exp);
			      rdr_RSA_decrypt(reader, buf80, buf80, 128, &er_n51Exp, &er_n51Mod, 1);

					sum=0;
					for (j=0; j<9; j++)
					{
						uint32_t nextSum=(buff1[j]&0x80) ? 1:0;
						buff1[j]=(sum+2*buff1[j])^buff3[j];
						sum=nextSum;
					}

					memcpy(buffG,buff1,8);
					memcpy(buff3,_51src_p+2,3);
					for (i=0; i<8; i++)
						buffG[i] = buff3[_51PT->P2[i]-2] ^= buffG[i];
					break;
				}
			#else
				{
					i=0;
					for(j=0;j<3;j++) {
					// sky(???)
					//	k = seka2_step51[i+j-1];
						k = seka2_step51[j];
						buf4[j] = _51src_p[k];
					}
					buf4[3] = _51src_p[1] & 0x0F;
					for(j=0;j<60;j+=20) memcpy (&buf40[j], _Hashdw, Hashlen);
					memcpy (&buf40[60], buf4, 4);
					memcpy(xorBuf51, &_51src_p[2], 3);
					memcpy(tmpHash, _Hashdw,8);
					for(i=0;i<8;i++)
					{
						xorBuf51[(xorptr[i]-3)] ^= _Hashdw[i];
						_Hashdw[i] = xorBuf51[(xorptr[i]-3)];
					}
					for(i=0;i<6;i++) memcpy (&buf80[buf80mask[i]], _Hashdw, Hashlen);
					memcpy (&buf80[20], buf4, 4);
					memcpy (&buf80[64], buf4, 4);
					memcpy(bufTMP,buf80,9);
					for (i=0; i<0x40; i++)
					{
						buf80[i*2]^= buf40[i];
						buf80[(i*2)+1]^=0xFF;
					}
					buf80[0x80]=0;
					buf80[0x81]=0;
					// RSA decrypt
					BN_bin2bn(seka2_n51Mod, 130, &er_n51Mod);
					BN_bin2bn(seka2_n51Exp, 1, &er_n51Exp);
			      rdr_RSA_decrypt(reader, buf80, buf80, 130, &er_n51Exp, &er_n51Mod, 1);
					value = 0;
					for (i=0; i<9; i++)
					{
						nextvalue = (buf80[i] & 0x80) ? 1 : 0;
						value += 2 * buf80[i];
						buf80[i]= value ^ bufTMP[i];
						value= nextvalue;
					}
					memcpy(_Hashdw, buf80, 8);
					memcpy(xorBuf51, &_51src_p[2], 3);
					for(i=0;i<8;i++)
					{
						xorBuf51[(xorptr[i+8]-3)] ^= _Hashdw[i];
						_Hashdw[i] = xorBuf51[(xorptr[i+8]-3)];
					}
					memcpy(buffG, _Hashdw, 8);
					memcpy(_Hashdw, tmpHash,8);
					break;
				}
			#endif
	}

	// FINAL PERMUTATION
	switch (_51Algo)
	{
		case 0x05:
		case 0x09:
			// special permutation seca2 V7.3+
			switch (seka_prid)
			{
				case 0x6A:
				case 0x6B:
				case 0x6C:
				case 0x6D:
					memcpy(buffG1,buffG,8);
					buffG[2]=buffG1[5];
					buffG[6]=buffG1[4];
					buffG[1]=buffG1[3];
					buffG[7]=buffG1[2];
					buffG[4]=buffG1[1];
					buffG[5]=buffG1[6];
					buffG[0]=buffG1[0];
					buffG[3]=buffG1[7];
					break;
			}
			break;
	}

	xseka_nano51_Crypto(_Dcw_p, buffG,  (_51src_p[1]>>6)&0x03, _51src_p[0]&0x80);

	// FINAL PERMUTATION
	xseka_nano51_Permute(buffF,_51src_p, xorptr_2);
	xseka_xxor(_Dcw_p,  8,_Dcw_p,  buffF);
	xseka_xxor(_Dcw_p+8,8,_Dcw_p+8,buffF);

	xseka_nano51_Crypto(_Dcw_p, _Hashdw, (_51src_p[1]>>4)&0x03, _51src_p[0]&0x40);
	return 1;
}
//----------------------------------------------------------------------
//----------------------------------------------------------------------
//----------------------------------------------------------------------
//----------------------------------------------------------------------
//----------------------------------------------------------------------
//----------------------------------------------------------------------
//----------------------------------------------------------------------
//======================================================================
//======================================================================
//======================================================================
//======================================================================
static int
xseka_chkSignatures(void)
{
	#ifdef _CANAL_NL_SUPPORT_
		if (xseka_nl_Isprovid(seka_prid)) return 0;
	#endif	// _CANAL_NL_SUPPORT_
	return 1;
}

static int
xseka_chkDeskey(struct s_reader *reader, uint16_t seka2, uint32_t provid, uint8_t keynr, uint8_t *cDeskey)
{
	int ksize = (seka2) ? 16 : 8;

	if (er_KPRID == provid && er_KNR == keynr)
	{
		memcpy(cDeskey, er_KKEY, 0x10);
		MYEMU_TRACE("xseka:KEY.%02X:%02X:%02X..%02X\n", provid, keynr, cDeskey[0], cDeskey[ksize-1]);
		return 1;
	}

	if (!XEMUKEY_Searchkey(reader, CASS_SEKA, provid, keynr, cDeskey, ksize))
	{
		MYEMU_TRACE("xseka:KEY{%04X.%02X} not found\n", provid, keynr);
		return 0;
	}
	er_KNR = keynr;
	er_KPRID = provid;
	er_KFOUND = 1;
	memcpy(er_KKEY, cDeskey, ksize);
	MYEMU_TRACE("xseka:KEY.%02X:%02X:%02X..%02X\n", provid, keynr, cDeskey[0], cDeskey[ksize-1]);
	return 1;
}



int
XSEKA_Process(struct s_reader *reader, ECM_REQUEST *er, uint8_t *cw)
{
	uint8_t	*Ecm_p;
	uint8_t	*crypt;
	uint8_t 	*T1, *T2;
	uint8_t 	*source = 0;
	uint32_t	provid;
	uint8_t 	pk[16], signatures[20];
	uint8_t 	workbuf[256];
	// actually 16 bytes used for processing, but SHA needs more
	uint8_t 	_dwHAsh[28];
	uint8_t 	*_Dcw_p   = 0;
	uint8_t 	*_51src_p = 0;
	int _0fMax	 = 0;

	int hx;
	int ident;
	int p4;
	int sMode;
	int bSekaSE = 0;
	int bSeka2 = 0;
	int bSignature = 0;
	int chkSignature = 0;
	int msgsize, keynr;
	int decrlen;
	int i;

	Ecm_p = er->ecm;
//	memcpy(Ecm_p, ECM_TEST, SCT_LEN(ECM_TEST));
	myprdump("Seka::Ecm_p", Ecm_p, SCT_LEN(Ecm_p));
	msgsize = xseka_sct_payload(Ecm_p, (uint8_t **)&source);
	if (!source) return 0;
	myprdump("Seka::source", source, msgsize);

	ident = xseka_sct_prid(Ecm_p);
	keynr = xseka_sct_keynr(Ecm_p);
	sMode = xseka_sct_sysmode(Ecm_p);
	// RAI
	if (ident == 0x0202) ident = 0x0030;
	if (ident == 0x02E2) ident = 0x0030;
	//
	// 	SEKA_2
	// 	PROV:006A,006C (??? source[0]:0x00, keynr:0x0E)
	if (source[0] == 0x10) bSeka2 = 1;
	if (xseka_isSeka2available(ident))
	{
		MYEMU_TRACE("xseka:SEKA2{%04X}\n", ident);
		return 0;
	}
	MYEMU_TRACE("xseka:(%04X:%02X)Len=%02X\n", ident, keynr, msgsize);

	seka_prid = ident;
	provid = ident;

	if (!xseka_chkDeskey(reader, bSeka2, provid, keynr&0xf, pk)) return 0;
	if (!(sMode & 0x10)) memcpy(pk + 8, pk, 8);

	if (bSeka2)
	{
		if (msgsize < 0x5C)
		{
			MYEMU_TRACE("xseka:ECM length too small (%d)\n", msgsize);
			return 0;
		}
		if (keynr & 0x80)
		{
			MYEMU_TRACE("xseka:SE enabled\n");
			bSekaSE = 1;
		}
		// select suitable provi and issuer_p
		seka2_provi  = xseka_getSeka2provi(ident);
		seka2_issuer = xseka_getSeka2issuer(ident);
		if (!seka2_provi)  return 0;
		if (!seka2_issuer) return 0;

		if (bSekaSE)
		{
			xseka_pre_sse_core(source, msgsize - 0x5A);
		}
		// choose suitable RSA keys
		p4 = source[1] & 7;
		if (p4 == 3) p4 = 1;
		else if (p4 == 7) p4 = 2;
		else p4 = 0;

		// RSA decrypt
		crypt = source + (msgsize - 0x5A);
		BN_bin2bn(seka2_provi->ecmMods[p4], 90, &er_ecmMod);
		BN_bin2bn(seka2_provi->ecmExps[p4],  6, &er_ecmExp);
      rdr_RSA_decrypt(reader, crypt, crypt, 90, &er_ecmExp, &er_ecmMod, 1);
		if (bSekaSE)
		{
			// PostSSE needed
			int signp = msgsize - source[msgsize - 1] - 9;

			if (signp >= (msgsize - 9) || source[signp] != 0x82)
			{
				MYEMU_TRACE("xseka:RSA decrypt failed, signatures pointer not found\n");
				return 0;
			}
			xseka_post_sse_core(source, signp);
		}
	}

	hx = keynr >> 4;
 	if (hx == 0x9)
 	{
		T1 = seka2_issuer->t19x;
		T2 = seka2_issuer->t29x;
	}
	else
 	if (hx == 0xB)
 	{
		T1 = seka2_issuer->t1Bx;
		T2 = seka2_issuer->t2Bx;
	}
	else
 	if (hx == 0xF)
 	{
		T1 = seka2_issuer->t1Fx;
		T2 = seka2_issuer->t2Fx;
	}
	else
	{
		T1 = seka_T1;
		T2 = seka_T2;
	}

//	myprdump("T1", T1, 16);
//	myprdump("T2", T2, 16);
//	myprdump("MT", seka2_issuer->masktab, 16);

	decrlen = msgsize;
	memcpy(workbuf, source, msgsize);

	if (bSekaSE)
	{
		decrlen -= workbuf[msgsize - 1];
		MYEMU_TRACE("xseka:decrlen = %d\n", decrlen);
		if (decrlen < 8) return 0;

		SHA1_sekaSignature(workbuf,
						decrlen - 8,
						signatures,
						TRUE,
						seka2_issuer->shapad,
						seka2_issuer->shaend);

		xseka_mod_signature(signatures, pk);

		xseka_Encrypt(signatures, pk, T1, T2);
//		myprdump("signatures", signatures, 8);

		if (xseka_chkSignatures())
		{
			if (memcmp(signatures, &workbuf[decrlen-8], 8))
			{
				MYEMU_TRACE("xseka:signatures check failed before SE decrypt\n");
				return 0;
			}
		}

		if (!xseka_sse_Decrypt(workbuf + 2, pk, msgsize - 2, 8, T1, T2))
		{
			MYEMU_TRACE("xseka:SE decrypt failed\n");
			return 0;
		}
	}
	else
	{
		xseka_calc_signatures(workbuf, decrlen - 8, signatures, pk, T1, T2);
	}

	memset(_dwHAsh,0,sizeof(_dwHAsh));

	for (i=0 ; i<decrlen; )
	{
		uint8_t 	param = workbuf[i++];
		uint8_t 	extra = (param >> 4) & 0x0f;

		switch (extra)
		{
			case 0x0d: extra=0x10; break;
			case 0x0e: extra=0x18; break;
			case 0x0f: extra=0x20; break;
		}
		myprintf("xseka;:nano:%02X.%d\n", param, extra);

		switch (param)
		{
			case 0x0f:
				if (bSekaSE) _0fMax++;
				break;

			case 0x51:
				if (bSekaSE) _51src_p = &workbuf[i];
				break;

			case 0xd1:
				_Dcw_p = &workbuf[i];
				if (bSekaSE)
				{
					SHA1_sekaSignature(workbuf, i, _dwHAsh, FALSE, 0x00, 0x00);
					memcpy(&_dwHAsh[20],_dwHAsh,20);
					xseka_Decrypt(&_dwHAsh[20], pk, seka2_issuer->t19x, seka2_issuer->t29x);
					SHA1_sekaSignature(_dwHAsh, 28, _dwHAsh, FALSE, 0x00, 0x00);
				}
				break;

			case 0x82:
				bSignature = 1;
				if (!bSekaSE) chkSignature = 1;
				if (xseka_chkSignatures()) chkSignature = 1;
				if (!chkSignature) break;

				if (memcmp(&workbuf[i],signatures,8))
				{
					MYEMU_TRACE("xseka:signatures check failed after decrypt\n");
					_Dcw_p = 0;
					bSignature = 0;
					i = decrlen;
				}
				break;
		}
		i+=extra;
	}

	if (_Dcw_p && bSignature)
	{
		if (!_0fMax || xseka_nano0f_Process(_0fMax,_dwHAsh,pk,T1,T2))
		{
			if (bSekaSE)
			{
				xseka_pre_cw(_Dcw_p);
			}
			if (!_51src_p || xseka_nano51_Process(reader, _Dcw_p,_51src_p,_dwHAsh,T1,T2))
			{
				xseka_Decrypt(&_Dcw_p[0],pk,T1,T2);
				xseka_Decrypt(&_Dcw_p[8],pk,T1,T2);
			//	myprdump("decrypted CW", _Dcw_p, 16);

				if (bSekaSE)
				{
					xseka_post_cw(_Dcw_p);
				}
				memcpy(cw, &_Dcw_p[0], 8);
				memcpy(cw+8, &_Dcw_p[8], 8);
				MYEMU_TRACE("xseka:cw{%02X...%02X,%02X...%02X}\n", cw[0], cw[7], cw[8], cw[15]);
				return 1;
			}
		}
	}
	MYEMU_TRACE("xseka:cw failed.\n");
	return 0;
}


void
XSEKA_Cleanup(void)
{
	MYEMU_TRACE("xseka:clean\n");
	er_KFOUND = 0;
	er_KNR 	 = 0;
	er_KPRID	 = 0x0;
	memset(er_KKEY, 0x0, 16);
}

#endif	// defined(__XCAS_SEKA__)
#endif	// defined(MODULE_XCAS)

